[
{
	"uri": "/",
	"title": "AWS RDS PostgreSQL",
	"tags": [],
	"description": "",
	"content": "Let start with AWS RDS PostgreSQL Overall In this lab, you\u0026rsquo;ll learn the basics and practice of Amazon RDS PostgreSQL\nContent Introduction Start with PostgreSQL Create RDS PostgreSQL Database Instance Connect to pgAdmin4 Helpful Resources Clean up resources "
},
{
	"uri": "/4-connectopgadmin4/4-1-configuretheclient/",
	"title": "Configure the database client",
	"tags": [],
	"description": "",
	"content": "After Amazon RDS provisions your DB instance, you can use any standard SQL client application to connect to the instance. Before you can connect, the DB instance must be available and accessible. Whether you can connect to the instance from outside the VPC depends on how you created the Amazon RDS DB instance:\nIf you created your DB instance as public, devices and Amazon EC2 instances outside the VPC can connect to your database. If you created your DB instance as private, only Amazon EC2 instances and devices inside the Amazon VPC can connect to your database. In this chapter, we will use pgAdmin4 to connect to a RDS for PostgreSQL DB instance, so we need create DB as public.\nYou can use the open-source tool pgAdmin4 to connect to your RDS for PostgreSQL DB instance. You can download and install pgAdmin from http://www.pgadmin.org/ without having a local instance of PostgreSQL on your client computer\n1.Launch the pgAdmin4 application on your client computer.\n2.On the Dashboard tab, choose Add New Server. 3.In the Create - Server dialog box, type a name on the General tab to identify the server in pgAdmin4. 4.In the Connection tab, type the following information from your DB instance:\nFor Host, type the endpoint you have retrieve in the step 3.2, for example mypostgresql.c6c8dntfzzhgv0.us-east-2.rds.amazonaws.com. For Port, type the assigned port. For Username, type the user name that you entered when you created the DB instance. For Password, type the password that you entered when you created the DB instance. 5.Choose Save. The server has been added to the pgAdmin4 and its dashboard is visible on the screen: If you have any problems connecting, see Troubleshooting connections to your RDS for PostgreSQL instance.\n"
},
{
	"uri": "/3-createrdspostgresql/3-1-createdbinstance/",
	"title": "Create DB instane",
	"tags": [],
	"description": "",
	"content": "1.Open AWS Management console,\nFind RDS Select RDS 2.Click Create database to start the configuration process. In the Choose a database creation method section, ensure the Standard Create option is selected. Next, in the Engine options section, choose the PostgreSQL engine type and the PostgreSQL 15.3-R2 version. In the Templates section, select Free tier.\nWhen using RDS free tier which has not support feature Availability and Durability.\nIn the Settings section, set the DB instance identifier to rdspg-fcj-labs. Configure the name and password of the master database user, with the most elevated permissions in the database.\nIn the DB instance size section, select Burstable classes, and choose db.t3.micro in the size drop-down\nIn the Storage Section, leave with default setting.\nExpand Storage autoscaling, then Uncheck the Enable storage autoscaling box. In the Connectivity section,\nPublic access choose yes Then leave with default setting In the Database authentication section, choose Password authentication In the Monitoring section, we will use default setting In the Additional configuration,\nFill your Initial database name\nUncheck Enable automated backups\nUncheck Enable encryption Check all option in Log exports\nCheck Enable auto minor version upgrade\nChoose No preference for Maintenance window\nFinally, review Estimated Monthly costs then select Create database "
},
{
	"uri": "/1-introduce/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "PostgreSQL has become the preferred open source relational database for many enterprise developers and startups, powering leading business and mobile applications. Amazon RDS makes it easier to set up, operate, and scale PostgreSQL deployments on the cloud. With Amazon RDS, you can deploy scalable PostgreSQL deployments in minutes with cost-efficient and resizable hardware capacity. Amazon RDS manages complex and time-consuming administrative tasks such as PostgreSQL software installation and upgrades, storage management, replication for high availability and read throughput, and backups for disaster recovery.\nAmazon RDS for PostgreSQL gives you access to the capabilities of the familiar PostgreSQL database engine. This means that the code, applications, and tools you already use today with your existing databases can be used with Amazon RDS. Amazon RDS for PostgreSQL currently supports PostgreSQL 9.6, 10, 11, 12, 13, 14, and 15. With Trusted Language Extensions (TLE) for PostgreSQL, you can build high performance extensions and safely run them on Amazon RDS using popular trusted languages without needing AWS to certify code.\nBy using AWS RDS PostgreSQL, you will get the following benefit below:\nEasier, managed deployments Fast, predictable storage Backup and recovery High availability and read replicas Monitoring and metrics Isolation and security "
},
{
	"uri": "/2-startwithpostgresql/2-1-pgadmin/",
	"title": "pgAdmin4",
	"tags": [],
	"description": "",
	"content": "The pgAdmin4 tool is a very popular database administration and development platform for the PostgreSQL database. We will use pgAdmin to help introduce PostgreSQL to you.\npgAdmin can be installed locally on your desktop or it can be run on a server and accessed via a web browser. In this lab, we will deploy pgAdmin in your desktop via link download image.\n"
},
{
	"uri": "/2-startwithpostgresql/2-2-databaseschemas/",
	"title": "Database and Schemas",
	"tags": [],
	"description": "",
	"content": "Welcome to PostgreSQL! If this is your first time looking at PostgreSQL, we encourage you to check out the official About PostgreSQL webpage.\nIn this module, we are going to explore Databases and Schemas.\nThis chapter assumes you have setup and configured pgAdmin. If you haven\u0026rsquo;t, please complete the pgAdmin module before proceeding.\nExplore Databases 1.In your pgAdmin tool, click the \u0026gt; in front of rdspg-fcj-labs to expand it.\nYou see 3 breakouts: Databases, Login/Group Roles, and Tablespaces.\nIn this section, we will focus on Databases. And we\u0026rsquo;ll cover Login/Group Roles in a later section.\n2.Expand the Databases node.\nFrom a terminology standpoint, the PostgreSQL instance (rdspg-fcj-labs) you have created is known as a PostgreSQL cluster. A cluster contains one or more databases. While the users/roles of a cluster are shared across a cluster, no data is shared across databases. In other words, when a customer connects to a cluster, that connection is required to specify the database it wants to work with and that connection can only work within a single database at a time.\nyou see a handful of databases within the pglab cluster.\nWhat is the `rdsadmin` database ?\rThe database named rdsadmin is a database that is reserved for use by the RDS/Aurora control plane.\r3.Right-click on the Databases node and choose Create, then click Databases\n4.Name the database first_database (but don\u0026rsquo;t save it yet)\nThe database has an owner. This role can control and assign permissions for this database to other roles. The owner defaults to the role you are currently logged in with pgAdmin. Also note that you can alter the owner of most PostgreSQL objects even after they are originally created.\n5.Now click on the Definition tab\nThere are various settings that can be changed. You don\u0026rsquo;t need to change anything for now.\n6.Click on the SQL tab\nThe SQL tab shows you a preview of the generated SQL command that pgAdmin is going to run.\n7.Click Save 8.Find your new database in the navigator and expand it. Explore Schemas A database contains one or more named schemas, which in turn contain tables and other objects like views and functions. The objects in a given PostgreSQL schema can be owned by different users and the schema name has no implied correlation to the name of the schema owner.\nAs described in the PostgreSQL Documentation\n\u0026quot; The same object name can be used in different schemas without conflict; for example, both schema1 and myschema may contain tables named mytable. Unlike databases, schemas are not rigidly separated: a user may access objects in any of the schemas in the database he is connected to, if he has privileges to do so.\nThere are several reasons why one might want to use schemas:\nTo allow many users to use one database without interfering with each other. To organize database objects into logical groups to make them more manageable. Third-party applications can be put into separate schemas so they cannot collide with the names of other objects. Schemas are analogous to directories at the operating system level, except that schemas cannot be nested.\u0026quot;\n1.Expand the Schemas node and see a default public schema.\n2.Right-click on the Schemas node and choose Create, then click Schema.\n3.Name the schema first_schema\nThe schemas have an owner and also have security permissions and default privileges for new objects created in the schema (you can click on the Security tab and the Default Permissions tab in the Create Schema dialog if you want).\n4.Click Save to create the new schema.\nPostgreSQL schemas can be different from how other databases like Oracle implement schemas. In Oracle, schemas are directly mapped 1:1 to users. In PostgreSQL, schemas are not coupled directly to a specific user(role).\nAs discussed in the documentation ,\n\u0026ldquo;In the SQL standard, the notion of objects in the same schema being owned by different users does not exist. Moreover, some implementations do not allow you to create schemas that have a different name than their owner. In fact, the concepts of schema and user are nearly equivalent in a database system that implements only the basic schema support specified in the standard. Therefore, many users consider qualified names to really consist of username.tablename. This is how PostgreSQL will effectively behave if you create a per-user schema for every user. Also, there is no concept of a public schema in the SQL standard. For maximum conformance to the standard, you should not use (perhaps even remove) the public schema.\u0026rdquo;\nA note about the search_path Referencing objects via Qualified names, such as first_schema.first_table, is tedious to write, and hard-coding a particular schema name into an application is not ideal. The solution is to use unqualified names, such as first_table and this is made possible via the PostgreSQL search_path.\nAs discussed in the documentation ,\n\u0026ldquo;The system determines which table is meant by following a search_path, which is a list of schemas to look in. The first matching table in the search path is taken to be the one wanted. If there is no match in the search path, an error is reported, even if matching table names exist in other schemas in the database.\nThe first schema named in the search path is called the current schema. Aside from being the first schema searched, it is also the schema in which new tables will be created if the CREATE TABLE command does not specify a schema name.\u0026rdquo;\nBy default, the search_path is set to $user,public. As the documentation states\n\u0026ldquo;The first element specifies that a schema with the same name as the current user is to be searched. If no such schema exists, the entry is ignored. The second element refers to the public schema that we have seen already.\u0026rdquo;\nIt should be noted that PostgreSQL does not have the concept of synonyms like certain other databases. You can use the search_path to handle some, but not all, of the capabilities that synonyms offer. For an example of implementing other synonym-like functionality in PostgreSQL, see this blog post .\nCongratulations!\nYou have learned the basics about PostgreSQL Databases and Schemas.\n"
},
{
	"uri": "/4-connectopgadmin4/4-2-queryingdata/",
	"title": "Querying Data",
	"tags": [],
	"description": "",
	"content": "After using pgAdmin4 to conntect to RDS PostgreSQL. Now We can perform the basic query statements in this chapter:\nCreate table fcj_users in the pglab database Insert data into the table fcj_users View all the recording in the table View full name user and nationality Get all user from Swedish or American and date of birth from 1980 to 1990. Sort output list descending by date_of_birth List top 5 the youngest users List top 5 the oldest users Check whether the user is missing a date of birth, or first name or last name Right-click on the name of the database to open the menu and click on the “Query Tool” button from the list:\n1.Create table fcj_users in the pglab database\nType the following query in the query tool to create a new table:\nCREATE TABLE fcj_user(\ruser_id SERIAL NOT NULL PRIMARY KEY,\rfirst_name VARCHAR(100),\rlast_name VARCHAR(100),\rgender char(1),\rdate_of_birth DATE,\rnationality VARCHAR (20)\r) 2.Insert data into the table fcj_users\nInsert the data into the fcj_users table using the following query:\nINSERT INTO fcj_users (first_name,last_name,gender,date_of_birth,nationality) VALUES\r(\u0026#39;Malin\u0026#39;,\u0026#39;Akerman\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1978-05-12\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Tim\u0026#39;,\u0026#39;Allen\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1953-06-13\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Julie\u0026#39;,\u0026#39;Andrews\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1935-10-01\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Ivana\u0026#39;,\u0026#39;Baquero\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1994-06-11\u0026#39;,\u0026#39;Bristish\u0026#39;),\r(\u0026#39;Lorraine\u0026#39;,\u0026#39;Bracco\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1954-10-02\u0026#39;,\u0026#39;Mexican\u0026#39;),\r(\u0026#39;Alice\u0026#39;,\u0026#39;Braga\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1983-04-15\u0026#39;,\u0026#39;Japanese\u0026#39;)\r(\u0026#39;Marlon\u0026#39;,\u0026#39;Brando\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1924-04-03\u0026#39;,\u0026#39;American\u0026#39;)\r(\u0026#39;Adrien\u0026#39;,\u0026#39;Brody\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1973-04-14\u0026#39;,\u0026#39;Mexican\u0026#39;),\r(\u0026#39;Peter\u0026#39;,\u0026#39;Carlberg\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1950-12-08\u0026#39;,\u0026#39;Chinese\u0026#39;),\r(\u0026#39;Gemma\u0026#39;,\u0026#39;Chan\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1982-11-29\u0026#39;,\u0026#39;Japanese\u0026#39;),\r(\u0026#39;Chen\u0026#39;,\u0026#39;Chang\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1976-10-14\u0026#39;,\u0026#39;Mexican\u0026#39;),\r(\u0026#39;Graham\u0026#39;,\u0026#39;Chapman\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1941-01-08\u0026#39;,\u0026#39;Japanese\u0026#39;),\r(\u0026#39;Pei-pei\u0026#39;,\u0026#39;Cheng\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1946-12-04\u0026#39;,\u0026#39;Mexican\u0026#39;),\r(\u0026#39;Maggie \u0026#39;,\u0026#39;Cheung\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1964-09-20\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Min-sik\u0026#39;,\u0026#39;Choi\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1962-05-30\u0026#39;,\u0026#39;Chinese\u0026#39;),\r(\u0026#39;Yun-fat\u0026#39;,\u0026#39;Chow\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1955-05-18\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;John\u0026#39;,\u0026#39;Cleese\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1939-10-27\u0026#39;,\u0026#39;British\u0026#39;),\r(\u0026#39;Paddy\u0026#39;,\u0026#39;Considine\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1973-09-05\u0026#39;,\u0026#39;Mexican\u0026#39;),\r(\u0026#39;Abbie\u0026#39;,\u0026#39;Cornish\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1982-08-07\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Brian\u0026#39;,\u0026#39;Cox\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1946-06-01\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Scatman\u0026#39;,\u0026#39;Crothers\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1910-05-23\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Russell\u0026#39;,\u0026#39;Crowe\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1964-04-07\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Tom\u0026#39;,\u0026#39;Cruise\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1962-07-03\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Darlan\u0026#39;,\u0026#39;Cunha\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1988-07-26\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Willem\u0026#39;,\u0026#39;Dafoe\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1955-07-22\u0026#39;,\u0026#39;British\u0026#39;),\r(\u0026#39;Paul\u0026#39;,\u0026#39;Dano\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1984-06-19\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Daniel\u0026#39;,\u0026#39;Day-Lewis\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1957-04-29\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Robert\u0026#39;,\u0026#39;De Niro\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1943-08-17\u0026#39;,\u0026#39;British\u0026#39;),\r(\u0026#39;Marion\u0026#39;,\u0026#39;Brando\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1924-04-03\u0026#39;,\u0026#39;American\u0026#39;),\r(null,\u0026#39;Denden\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1950-01-23\u0026#39;,\u0026#39;Mexican\u0026#39;),\r(\u0026#39;Leonardo\u0026#39;,\u0026#39;DiCaprio\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1974-11-11\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Peter\u0026#39;,\u0026#39;Dinklage\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1969-06-11\u0026#39;,\u0026#39;British\u0026#39;),\r(\u0026#39;Hiroki\u0026#39;,\u0026#39;Doi\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1999-08-10\u0026#39;,\u0026#39;Japanese\u0026#39;),\r(\u0026#39;Kirsten\u0026#39;,\u0026#39;Dunst\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1982-04-30\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Shelley\u0026#39;,\u0026#39;Duvall\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1949-07-07\u0026#39;,\u0026#39;British\u0026#39;),\r(\u0026#39;Ralph\u0026#39;,\u0026#39;Fiennes\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1962-12-22\u0026#39;,\u0026#39;British\u0026#39;),\r(\u0026#39;Leandro\u0026#39;,\u0026#39;Firmino\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1978-06-23\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Carrie\u0026#39;,\u0026#39;Fisher\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1956-10-21\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Harrison\u0026#39;,\u0026#39;Ford\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1942-07-13\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Darian\u0026#39;,\u0026#39;Cunha\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1988-07-26\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Jodie\u0026#39;,\u0026#39;Foster\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1962-11-19\u0026#39;,\u0026#39;Chinese\u0026#39;); 3.View all the recording in the table\nType the following query in the query tool to view all recording: SElECT * FROM fcj_users;\n4.View full name user and nationality\nType the following query in the query tool :\nSELECT first_name || \u0026#39; \u0026#39; || last_name || \u0026#39; from \u0026#39; || nationality AS \u0026#34;Full name\u0026#34; \u0026amp; nationality FROM fcj_users; 5.Get all user from Swedish or American and date of birth from 1980 to 1990. Sort output list descending by date_of_birth\nType the following query in the query tool :\nSELECT * FROM fcj_users\rWHERE nationality = \u0026#39;Swedish\u0026#39; OR\rnationality = \u0026#39;American\u0026#39; AND\rdate_of_birth BETWEEN \u0026#39;1980-01-01\u0026#39; AND \u0026#39;1990-12-31\u0026#39;\rORDER BY date_of_birth DESC; 6.List top 5 the youngest users\nType the following query in the query tool :\nSELECT * FROM fcj_users\rORDER BY date_of_birth DESC\rFETCH FIRST 5 ROW ONLY; 7.List top 5 the oldest users\nType the following query in the query tool :\nSELECT * FROM fcj_users\rORDER BY date_of_birth ASC\rFETCH FIRST 5 ROW ONLY; 9.Check whether the user is missing a date of birth, or first name or last name\nSELECT *\rFROM fcj_users\rWHERE date_of_birth IS NULL\rOR first_name IS NULL\rOR last_name IS NULL ; "
},
{
	"uri": "/3-createrdspostgresql/3-2-retrievebdinstancendpoint/",
	"title": "Retrieve DB instance endpoint",
	"tags": [],
	"description": "",
	"content": "The PostgreSQL database instance may take several minutes to provision. In order to connect to the DB instance and start using it in subsequent labs, you need to retrieve the DB instance endpoint.\nThe Endpoint \u0026amp; port section in the Connectivity and security tab of the details page displays the endpoint. Note this value down, as you will use them later. "
},
{
	"uri": "/2-startwithpostgresql/",
	"title": "Start with PostgreSQL",
	"tags": [],
	"description": "",
	"content": "This lab contains following tasks: Content pgAdmin Database and Schemas Tables and Datatypes Basic DML Role and Users Catalog and Data dictionary Session parameters "
},
{
	"uri": "/3-createrdspostgresql/",
	"title": "Create RDS PostgreSQL Database Instance",
	"tags": [],
	"description": "",
	"content": "This lab will walk you through the steps of creating a RDS PostgreSQL instance, and configuring the needed parameters. At the end of this lab you will have a database instance ready to be used for subsequent labs.\nThis lab contains following tasks: Content Create DB instance Retrieve DB instance endpoint Store user/password database in AWS Secrets Manager secret "
},
{
	"uri": "/3-createrdspostgresql/3-3-storeaccountinawssms/",
	"title": "Password management with Amazon RDS and AWS Secrets Manager",
	"tags": [],
	"description": "",
	"content": "Secrets Manager enables you to replace hardcoded credentials in your code, including passwords, with an API call to Secrets Manager to retrieve the secret programmatically. This helps ensure the secret can\u0026rsquo;t be compromised by someone examining your code, because the secret no longer exists in the code.\n1.Open AWS Management console,\nFind Secrets Manager Select Secrets Manager 2.Click Store a new secret to start the configuration process.\n3.In the Select secret type section,\nChoose Credentials for RDS database\nInput the User name (should be masteruser) and Password that you provided when you created the DB cluster previously. Next, in the Select which RDS database this secret will access section, choose the DB instance identifier you assigned to your instance (e.g. rdspg-fcj-labs). Click Next.\n4.Name the secret secretPostgresqlMasterUser and provide a relevant description for the secret, then click Next.\nBe sure to use the exact name (case-sensitive) of secretPostgresqlMasterUser to avoid having to edit some of the lab scripts later.\n5.Finally, in the Configure automatic rotation section, leave the option of Disable automatic rotation selected. In a production environment you will want to use database credentials that rotate automatically for additional security. Click Next. 6.In the Review section you have the ability to check the configuration parameters for your secret, before it gets created. Additionally, you can retrieve sample code in popular programming languages, so you can easily retrieve secrets into your application. Click Store at the bottom of the screen.\n"
},
{
	"uri": "/2-startwithpostgresql/2-3-tablesdatatypes/",
	"title": "Tables and Datatypes",
	"tags": [],
	"description": "",
	"content": "In this module, we are going to explore Tables and Datatypes.\nThis chapter assumes you have completed the Databases and Schemas chapter. If you haven\u0026rsquo;t, please complete the Databases and Schemas module before proceeding.\nWhat is a Table and why do I see PostgreSQL sometimes call them Relations ?\nFrom the PostgreSQL documentation ,\n\u0026ldquo;PostgreSQL is a relational database management system (RDBMS). That means it is a system for managing data stored in relations. Relation is essentially a mathematical term for table. The notion of storing data in tables is so commonplace today that it might seem inherently obvious, but there are a number of other ways of organizing databases. Files and directories on Unix-like operating systems form an example of a hierarchical database. A more modern development is the object-oriented database.\nEach table is a named collection of rows. Each row of a given table has the same set of named columns, and each column is of a specific data type. Whereas columns have a fixed order in each row, it is important to remember that SQL does not guarantee the order of the rows within the table in any way (although they can be explicitly sorted for display).\nTables are grouped into databases, and a collection of databases managed by a single PostgreSQL server instance constitutes a database cluster.\u0026rdquo;\nExplore Tables 1.In your pgAdmin tool, expand your first_schema inside your first_database.\nThe different kinds of objects (tables, views, functions, etc) that can be part of a PostgreSQL schema.\n2.Right-click on Tables and choose Create then select Table\n3.Name your table first_table.\nThere is an option to make your table partitioned. For this first_table, we will not use table partitioning.\nTable Partitioning in PostgreSQL is an interesting subject. It is interesting because table partitioning has evolved across the PostgreSQL versions. In earlier versions (version 9 and earlier), table partitioning was indirectly supported via the PostgreSQL table inheritance feature (see below). Starting with PostgreSQL version 10, table partition became a native declarative feature. A key thing to remember is that the exact set of table partitioning features supported are tied to the PostgreSQL version. So, be sure you refer to the table partitioning documentation tied to the version of PostgreSQL you are using.\n4.Click on Columns to advance to the Columns tab. Then click on the + sign. Then enter col1 for the Name. Fill out text for the Data type. Click Yes for Not NULL. Click Yes for Primary Key.\nThere is an option to inherit columns from other tables. We will not use table inheritance for this first_table, but it is an interesting and useful PostgreSQL capability to be aware of.\nTable Inheritance in PostgreSQL can be a useful tool for database designers. Table inheritance lets a child table inherit all of the columns of its parent table(s). Further, you can write queries against parent tables that reference the rows of the parent table and all of its descendent tables, too. See the example in the table inheritance documentation to better understand the capabilities.\n5.Browse the available options on the other tabs and end up on the SQL tab. Then click Save.\nCongratulations!\nYou have learned the basics about PostgreSQL Tables and Datatypes.\n"
},
{
	"uri": "/2-startwithpostgresql/2-4-basicdml/",
	"title": "Basic DML (Data Manipulation Language)",
	"tags": [],
	"description": "",
	"content": "This chapter will talk about queries and basic DML.\nThis chapter assumes you have completed the Tables and Datatypes chapter. If you haven\u0026rsquo;t, please complete the Tables and Datatypes module before proceeding.\nInsert data into our first table 1.In your pgAdmin tool, right click on first_table under your first_schema inside your first_database. Choose Scripts, then click INSERT Script\nThis will create a boilerplate insert statement for our table that we can edit.\\\n2.Highlight the ? placeholder and replace it with 'my first row'. Don\u0026rsquo;t forget to use the ' single-quote mark to surround your text. 3.Click on the Play icon to execute this command.\nThis will run your command and insert your first row. What does \u0026#39;INSERT 0 1\u0026#39; mean ?\rThe 1 in INSERT 0 1 means that it inserted 1 row. The 0 is only applicable if the table uses the classic PostgreSQL OID (Object Identifier), and if so, the 0 represents the actual OID created. Otherwise, it will always return the value 0. These days you probably will not create tables using OIDs, but if you are curious you can read more about OIDs in the documentation .\rIs my row committed ?\rBy default, pgAdmin is set with AutoCommit on, so, yes, this new row should be committed. You can see/change the AutoCommit mode by clicking on the icon next to the Play icon in the pgAdmin Query Editor:\nQuery our first table 1.In your pgAdmin tool, right click on first_table under your first_schema inside your first_database. Choose Scripts, then click SELECT Script 2.Click on the Play icon to execute this command.\nThis will run your command and you should see your first row.\nCreate table second table if not exists 1.Using one of the open query editors, paste in the following create command and then click the Play icon to execute it:\ncreate table if not exists first_schema.second_table(\rcol_pk serial,\rcol_money numeric(12,2),\rcol_short_str varchar(100),\rcol_datetime timestamp(0) without time zone\r); Insert into our second table 1.Using one of the open query editors, paste in the following insert command and then click the Play icon to execute it:\nINSERT INTO first_schema.second_table(\rcol_money, col_short_str, col_datetime)\rVALUES (40.25, \u0026#39;short string\u0026#39;, TIMESTAMP \u0026#39;2004-10-19 10:23:54\u0026#39;) returning col_pk; Notice that because we specified returning col_pk, we see the auto-generated unique value of col_pk in the Data Output section. Remember that when we created second_table that we specified that col_pk used the SERIAL datatype (which is like the AUTO_INCREMENT datatype in other database engines).\nExperimenting with Datatype conversions 1.In one of the open query editors, paste the following select command and click the Play icon to execute it:\nSELECT \u0026#39;40.25\u0026#39; col1, 40.25 col2; Notice in the Data Output section that col1 is a text datatype while col2 is a numeric datatype.\nUnlike certain other databases (specifically Oracle), you do not need to have a FROM clause in your SELECT statement. So if you are in the habit of writing SELECT 'something' FROM dual; in Oracle, you can leave the FROM dual off in PostgreSQL. There is no dual table in PostgreSQL.\n2.Now run this query:\nSELECT \u0026#39;40.25\u0026#39; col1, 40.25 col2, \u0026#39;40.25\u0026#39;::numeric col3, numeric \u0026#39;40.25\u0026#39; col4, cast(\u0026#39;40.25\u0026#39; as numeric) col5; Notice in the Data Output section that col3, col4, and col5 are all examples of text datatypes that have been converted to numeric datatypes. These 3 columns demonstrate 3 ways that you can do datatype conversion in PostgreSQL SQL statements.\n"
},
{
	"uri": "/4-connectopgadmin4/",
	"title": "Connect to pgAdmin4",
	"tags": [],
	"description": "",
	"content": "This lab contains following tasks: Content Connect to pgAdmin4 Querying data "
},
{
	"uri": "/5-helpfulresources/",
	"title": "Helpful Resources",
	"tags": [],
	"description": "",
	"content": "To learn more about pgAdmin4, you can use the Help menu and browse the Online Help.\nBelow are some links to additional relevant content:\nManaging PostgreSQL users and roles RDS for PostgreSQL Common administrator responsibilities on Amazon RDS and Amazon Aurora for PostgreSQL databases Using IAM authentication to connect with pgAdmin Amazon Aurora PostgreSQL or Amazon RDS for PostgreSQL Securing Amazon RDS and Aurora PostgreSQL database access with IAM authentication Working with RDS and Aurora PostgreSQL logs: Part 1 Working with RDS and Aurora PostgreSQL logs: Part 2\n"
},
{
	"uri": "/2-startwithpostgresql/2-5-rolesusers/",
	"title": "Roles and Users",
	"tags": [],
	"description": "",
	"content": "\rThis chapter assumes you have completed the Basic DML chapter. If you haven\u0026rsquo;t, please complete the Basic DML module before proceeding.\nThis chapter will talk about PostgreSQL Roles . In PostgreSQL, a role encompasses the concept of both users and groups. The CREATE USER and CREATE GROUP statements are actually aliases for the CREATE ROLE statement. The difference is that a user is role with the LOGIN privilege.\nRoles are defined at the PostgreSQL cluster level and are valid in all databases within the cluster. Role are not created specific to an individual database.\nIn PostgreSQL, schemas are distinct concept from roles/users. This is different than databases such as Oracle.\nExploring Existing Roles In pgAdmin, expand the Login/Group Roles item under your PostgreSQL server.\nYou will see the existing and default roles defined in this PostgreSQL cluster. Notice that there are 2 types of icons that pgAdmin uses for roles. If the role has LOIGN privileges, then it is drawn as a user (such as rdsadmin and masteruser). Otherwise, it is displayed with a group icon.\\\nYou can also retrieve this same information by running the following sql query:\nSELECT rolname FROM pg_roles;\nCreate a new Role 1.Right-click on Login/Group Roles, then choose Create, then choose Login/Group role:\n2.Name the role first_role. 3.Browse through the other tabs of the Create role dialog, but don\u0026rsquo;t change anything. End up on the SQL tab. Then click Save. 4.Right-click on first_database and choose Query Tool icon. 5.Paste and run the following SQL to grant some privileges to your new role.\nGRANT USAGE ON SCHEMA first_schema TO first_role;\rGRANT SELECT ON first_schema.first_table TO first_role; we have granted the role both the ability to SELECT from the table, and also the ability to use the schema that contains the table.\nCreate a new User 1.Right-click on Login/Group Roles, then choose Create, then choose Login/Group role: 2.Name the role first_user.\n3.Click on the Definition tab. Then enter a Password you will remember.\n4.Click on the Privileges tab. Then set Can login? to Yes\n5.Click on the Membership tab. Then click in the Roles field and pick first_role\n6.Finally, click on the SQL tab to see what the SQL looks like. Then Save\nNow, right-click on the Servers node and choose Create, then click Server\n7.Name the new connection first_user_connection\n8.Click on the Connection tab. Enter the RDS endpoint for the hostname (see notes below if you need help finding it). Enter first_user for the Username. Enter your Password you just defined for the new user. Then click Save. 9.Expand the first_user_connection node, then expand Databases. Right-click on first_database, then choose Query Tool to open up a session as first_user. 10.Paste and run this SQL to see if our first_role grants work:\nselect * from first_schema.first_table; 11.Paste and run this SQL to test a table that we have not granted to first_role:\nselect * from first_schema.second_table; Read more about best practices for PostgreSQL User/Role management\nWant to create additional DBA users (similar to masteruser) for your RDS or Aurora PostgreSQL instance? Try this script :\n--replace thepassword with a real password\rCREATE ROLE new_dba_user WITH PASSWORD \u0026#39;thepassword\u0026#39; CREATEDB CREATEROLE LOGIN;\rGRANT rds_superuser TO new_dba_user; "
},
{
	"uri": "/2-startwithpostgresql/2-6-catalodatadictonary/",
	"title": "Catalog and Data dictionary",
	"tags": [],
	"description": "",
	"content": "\rThis chapter assumes you have completed the Basic DML chapter. If you haven\u0026rsquo;t, please complete the Basic DML module before proceeding.\nThis chapter introduces the PostgreSQL Data Dictionary.\nThe pg_catalog schema In addition to public and user-created schemas, each database contains a pg_catalog schema, which contains the system tables and all the built-in data types, functions, and operators.\nThese are a set of tables used to store dynamic and static metadata for the PostgreSQL database and can be thought of as the “data dictionary” for the database. These tables are used for internal “bookkeeping”-type activities. All System catalog tables start with the pg_*prefix and can be found in the pg_catalog schema\n1.In pgAdmin, expand the rdspg-fcj-labs node, then expand the Databases node, then expand the first_database node, then expand the Catalogs node, then expand the PostgreSQL Catalog, then expand Tables.\nYou can see the tables in the pg_catalog schema.\n2.Click on the first_database, then choose Query Tool icon\n3.Paste and run this command to see an example of querying the pg_catalog directly:\nselect * from pg_tables where schemaname='pg_catalog'; The Statistics Collector Views (also part of pg_catalog) The Statistics Collector is a special subsystem which collects runtime dynamic information about the current activities in the database instance. For example, statistics collector views are useful to determine how frequently a particular table is accessed and if the table is scanned or accessed using an index.\n1.Paste and run this command to see an example of one of the Statistics Collector views:\nSELECT * FROM pg_stat_activity WHERE STATE = 'active';\n2.lick on the rds-pg-labs node. Then click on Dashboard. Then click on Sessions in the Server activity section. Here, pgAdmin is showing you the same pg_stat_activity information for your PostgreSQL cluster.\nTip: Performance Insights is a great way to visualize current and historical activity and wait events. We encourage you to start with Performance Insights for performance-related diagnostics.\nPerformance Insights is a great way to visualize current and historical activity and wait events. We encourage you to start with Performance Insights for performance-related diagnostics.\n3.Paste and run this command to see an example of one of the Statistics Collector views: select * from information_schema.tables;\n"
},
{
	"uri": "/6-cleanup/",
	"title": "Clean up resources",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/2-startwithpostgresql/2-7-sessionparameters/",
	"title": "Session parameters",
	"tags": [],
	"description": "",
	"content": "\rThis chapter assumes you have completed the Basic DML chapter. If you haven\u0026rsquo;t, please complete the Basic DML module before proceeding.\nThis chapter will talk about PostgreSQL Parameters . Specifically, it will focus on parameters that can be changed at the session-level. For system-wide parameters, you would leverage RDS/Aurora\u0026rsquo;s Parameter Group mechanism.\n1.In pgAdmin, click on the rdspg-fcj-labs node, then click on Dashboard, then click on Configuration.\nThis shows you the current setting of all the PostgreSQL parameter settings.\n2.In the search box, type search\nThis filters down the list of parameter settings.\n3.Click on first_database, then choose Query Tool icon. Then paste and run the following SQL:\nSELECT * FROM pg_settings where context = 'user';\nThis shows you the parameter sessions that can be changed for a session, as well as their current setting.\n4.Paste and run the following SQL:\nshow search_path The SHOW command is another way to view the current value of a setting for your session.\n5.Paste and run the following SQL: show all This shows you yet another way to view the current value of all of the parameter settings for your session.\n6.Paste and try the following SQL: select * from first_table; This fails because PostgreSQL is not able to find a table named first_table in the schemas in the current search_path.\n7.Paste and try the following SQL: SET search_path TO first_schema, public; 8.Paste and try the following SQL again: select * from first_table; This now works because we updated the search_path parameter setting for our session.\nWhen making changes to system parameters via RDS/Aurora Parameter Groups, it is a good idea to confirm that your parameter change has been applied by using one of the techniques above, such as \u0026ldquo;SHOW ALL\u0026rdquo;, to confirm that the expected parameter value is in effect. Sometimes people can be confused because their Parameter Group change can be made but the actual parameter setting change does not happen until the next reboot. Confirming the value using \u0026ldquo;SHOW ALL\u0026rdquo; or one of the other methods can save you confusion and time\n"
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]