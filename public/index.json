[
{
	"uri": "/",
	"title": "AWS RDS PostgreSQL",
	"tags": [],
	"description": "",
	"content": "Let start with AWS RDS PostgreSQL Overall In this lab, you\u0026rsquo;ll learn the basics and practice of Amazon RDS PostgreSQL\nContent Introduction Preparation Start with PostgreSQL Create RDS PostgreSQL Database Instance Connect to pgAdmin4 Helpful Resources Clean up resources "
},
{
	"uri": "/2-preparation/2-1-createvpc/",
	"title": "Create a VPC",
	"tags": [],
	"description": "",
	"content": " Go to the VPC console and click Create VPC. For Resources to create, choose VPC and more. Enter a name for your VPC and select a CIDR block. The CIDR block is the range of IP addresses that will be available to your VPC. Make sure to choose a CIDR block that is large enough for your needs, but not so large that you waste IP addresses. Select values for Number of public subnets, Number of private subnets and NAT Gateway. 5. Review your VPC resources, then click Create VPC\n"
},
{
	"uri": "/1-introduce/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "PostgreSQL has become the preferred open source relational database for many enterprise developers and startups, powering leading business and mobile applications. Amazon RDS makes it easier to set up, operate, and scale PostgreSQL deployments on the cloud. With Amazon RDS, you can deploy scalable PostgreSQL deployments in minutes with cost-efficient and resizable hardware capacity. Amazon RDS manages complex and time-consuming administrative tasks such as PostgreSQL software installation and upgrades, storage management, replication for high availability and read throughput, and backups for disaster recovery.\nAmazon RDS for PostgreSQL gives you access to the capabilities of the familiar PostgreSQL database engine. This means that the code, applications, and tools you already use today with your existing databases can be used with Amazon RDS. Amazon RDS for PostgreSQL currently supports PostgreSQL 9.6, 10, 11, 12, 13, 14, and 15. With Trusted Language Extensions (TLE) for PostgreSQL, you can build high performance extensions and safely run them on Amazon RDS using popular trusted languages without needing AWS to certify code.\nBy using AWS RDS PostgreSQL, you will get the following benefit below:\nEasier, managed deployments Fast, predictable storage Backup and recovery High availability and read replicas Monitoring and metrics Isolation and security "
},
{
	"uri": "/3-startwithpostgresql/3-1-pgadmin/",
	"title": "pgAdmin4",
	"tags": [],
	"description": "",
	"content": "The pgAdmin4 tool is a very popular database administration and development platform for the PostgreSQL database. We will use pgAdmin to help introduce PostgreSQL to you.\npgAdmin can be installed locally on your desktop or it can be run on a server and accessed via a web browser. In this lab, we will deploy pgAdmin in your desktop via link download image.\n"
},
{
	"uri": "/4-connectordspostgresql/4-1-usingpgadmin4/",
	"title": "Using pgAdmin4 to connect to RDS PostgreSQL",
	"tags": [],
	"description": "",
	"content": "\rIn this section, we will use pgAdmin4 to connect to a RDS for PostgreSQL DB instance, so we need create DB as public.\nYou can use the open-source tool pgAdmin4 to connect to your RDS for PostgreSQL DB instance. You can download and install pgAdmin from http://www.pgadmin.org/ without having a local instance of PostgreSQL on your client computer\n1.Launch the pgAdmin4 application on your client computer.\n2.On the Dashboard tab, choose Add New Server.\n3.In the Create - Server dialog box, type a name on the General tab to identify the server in pgAdmin4.\n4.In the Connection tab, type the following information from your DB instance:\nFor Host, The Endpoint of the RDS PostgreSQL DB, for example mypostgresql.c6c8dntfzzhgv0.us-east-2.rds.amazonaws.com. For Port, type the assigned port. For Username, type the user name that you entered when you created the DB instance. For Password, type the password that you entered when you created the DB instance. In the SSH Tunnel tab, enable the SSH tunnel feature and enter the following information For Host: The hostname or IP address of the bastion host. For Port: The SSH port number. For Username: The username that you use to SSH into the bastion host. For Identity file: choose the keypair that you have selected when create ec2 bastion host. 5.Choose Save. The server has been added to the pgAdmin4 and its dashboard is visible on the screen: If you have any problems connecting, see Troubleshooting connections to your RDS for PostgreSQL instance.\n"
},
{
	"uri": "/2-preparation/2-2-createec2sg/",
	"title": "Create EC2 Security Group",
	"tags": [],
	"description": "",
	"content": "To create an EC2 security group in the AWS console: Go to the EC2 console. In the navigation pane, choose Security Groups. Choose Create Security Group. For VPC, choose the VPC where you want to create the security group. For Security group name, enter a descriptive name for the security group. For Description, enter a description for the security group. Modify Inbound Rule Modify Outbound Rule Click Create. Once you have created the security group for EC2 instances\n"
},
{
	"uri": "/3-startwithpostgresql/3-2-databaseschemas/",
	"title": "Database and Schemas",
	"tags": [],
	"description": "",
	"content": "Welcome to PostgreSQL! If this is your first time looking at PostgreSQL, we encourage you to check out the official About PostgreSQL webpage.\nIn this module, we are going to explore Databases and Schemas.\nThis chapter assumes you have setup and configured pgAdmin. If you haven\u0026rsquo;t, please complete the pgAdmin module before proceeding.\nExplore Databases 1.In your pgAdmin tool, click the \u0026gt; in front of rdspg-fcj-labs to expand it.\nYou see 3 breakouts: Databases, Login/Group Roles, and Tablespaces.\nIn this section, we will focus on Databases. And we\u0026rsquo;ll cover Login/Group Roles in a later section.\n2.Expand the Databases node.\nFrom a terminology standpoint, the PostgreSQL instance (rdspg-fcj-labs) you have created is known as a PostgreSQL cluster. A cluster contains one or more databases. While the users/roles of a cluster are shared across a cluster, no data is shared across databases. In other words, when a customer connects to a cluster, that connection is required to specify the database it wants to work with and that connection can only work within a single database at a time.\nyou see a handful of databases within the pglab cluster.\nWhat is the `rdsadmin` database ?\rThe database named rdsadmin is a database that is reserved for use by the RDS/Aurora control plane.\r3.Right-click on the Databases node and choose Create, then click Databases\n4.Name the database first_database (but don\u0026rsquo;t save it yet)\nThe database has an owner. This role can control and assign permissions for this database to other roles. The owner defaults to the role you are currently logged in with pgAdmin. Also note that you can alter the owner of most PostgreSQL objects even after they are originally created.\n5.Now click on the Definition tab\nThere are various settings that can be changed. You don\u0026rsquo;t need to change anything for now.\n6.Click on the SQL tab\nThe SQL tab shows you a preview of the generated SQL command that pgAdmin is going to run.\n7.Click Save 8.Find your new database in the navigator and expand it. Explore Schemas A database contains one or more named schemas, which in turn contain tables and other objects like views and functions. The objects in a given PostgreSQL schema can be owned by different users and the schema name has no implied correlation to the name of the schema owner.\nAs described in the PostgreSQL Documentation\n\u0026quot; The same object name can be used in different schemas without conflict; for example, both schema1 and myschema may contain tables named mytable. Unlike databases, schemas are not rigidly separated: a user may access objects in any of the schemas in the database he is connected to, if he has privileges to do so.\nThere are several reasons why one might want to use schemas:\nTo allow many users to use one database without interfering with each other. To organize database objects into logical groups to make them more manageable. Third-party applications can be put into separate schemas so they cannot collide with the names of other objects. Schemas are analogous to directories at the operating system level, except that schemas cannot be nested.\u0026quot;\n1.Expand the Schemas node and see a default public schema.\n2.Right-click on the Schemas node and choose Create, then click Schema.\n3.Name the schema first_schema\nThe schemas have an owner and also have security permissions and default privileges for new objects created in the schema (you can click on the Security tab and the Default Permissions tab in the Create Schema dialog if you want).\n4.Click Save to create the new schema.\nPostgreSQL schemas can be different from how other databases like Oracle implement schemas. In Oracle, schemas are directly mapped 1:1 to users. In PostgreSQL, schemas are not coupled directly to a specific user(role).\nAs discussed in the documentation ,\n\u0026ldquo;In the SQL standard, the notion of objects in the same schema being owned by different users does not exist. Moreover, some implementations do not allow you to create schemas that have a different name than their owner. In fact, the concepts of schema and user are nearly equivalent in a database system that implements only the basic schema support specified in the standard. Therefore, many users consider qualified names to really consist of username.tablename. This is how PostgreSQL will effectively behave if you create a per-user schema for every user. Also, there is no concept of a public schema in the SQL standard. For maximum conformance to the standard, you should not use (perhaps even remove) the public schema.\u0026rdquo;\nA note about the search_path Referencing objects via Qualified names, such as first_schema.first_table, is tedious to write, and hard-coding a particular schema name into an application is not ideal. The solution is to use unqualified names, such as first_table and this is made possible via the PostgreSQL search_path.\nAs discussed in the documentation ,\n\u0026ldquo;The system determines which table is meant by following a search_path, which is a list of schemas to look in. The first matching table in the search path is taken to be the one wanted. If there is no match in the search path, an error is reported, even if matching table names exist in other schemas in the database.\nThe first schema named in the search path is called the current schema. Aside from being the first schema searched, it is also the schema in which new tables will be created if the CREATE TABLE command does not specify a schema name.\u0026rdquo;\nBy default, the search_path is set to $user,public. As the documentation states\n\u0026ldquo;The first element specifies that a schema with the same name as the current user is to be searched. If no such schema exists, the entry is ignored. The second element refers to the public schema that we have seen already.\u0026rdquo;\nIt should be noted that PostgreSQL does not have the concept of synonyms like certain other databases. You can use the search_path to handle some, but not all, of the capabilities that synonyms offer. For an example of implementing other synonym-like functionality in PostgreSQL, see this blog post .\nCongratulations!\nYou have learned the basics about PostgreSQL Databases and Schemas.\n"
},
{
	"uri": "/2-preparation/",
	"title": "Preparation Step",
	"tags": [],
	"description": "",
	"content": "Overall In this section, we\u0026rsquo;ll prepare all resource for series workshop about RDS PostgreSQL.\nContent Create a VPC Create EC2 Security Group Create RDS Security Group Create DB Subnet Group Create EC2 AppServer Create EC2 bastion host Create RDS PostgreSQl "
},
{
	"uri": "/3-startwithpostgresql/",
	"title": "Start with PostgreSQL",
	"tags": [],
	"description": "",
	"content": "This lab contains following tasks: Content pgAdmin Database and Schemas Tables and Datatypes Basic DML Role and Users Catalog and Data dictionary Session parameters "
},
{
	"uri": "/4-connectordspostgresql/4-2-usingpsql/",
	"title": "Using EC2 instance to connect to RDS PostgreSQL",
	"tags": [],
	"description": "",
	"content": "To connect to an RDS PostgreSQL DB using an EC2 instance, follow these steps: Connect to EC2 instance (App server) via MobaXterm. Download and install updates linux OS. You can use the following command to download and install: cat /etc/os-release cat /etc/system-release\rsudo yum update -y Add PostgreSQL Amazon extras repository PostgreSQL is part of the amazon extras library.\nTo check the available postgresql version in the Amazon extras repository:\namazon-linux-extras | grep postgresql To enable the Amazon extras repository:\nsudo amazon-linux-extras enable postgresql14 Install the psql client: sudo amazon-linux-extras install postgresql14\nTo install the pgbench: sudo yum install postgresql-contrib\nRecheck verions psql \u0026amp; pgbench psql --version\rpgbench --version Connect to the remote RDS PostgreSQL: psql -h rdspg-fcj-labs.cssuddr073hp.us-east-1.rds.amazonaws.com -U masteruser -d pglab\n-h: RDS PostgreSQL endpoint -U: username for the master user of your database instance -d: name for database "
},
{
	"uri": "/2-preparation/2-3-createrdssg/",
	"title": "Create RDS Security Group",
	"tags": [],
	"description": "",
	"content": "To create an EC2 security group in the AWS console: Go to the EC2 console. In the navigation pane, choose Security Groups. Choose Create Security Group. For VPC, choose the VPC where you want to create the security group. For Security group name, enter a descriptive name for the security group. For Description, enter a description for the security group. Modify Inbound Rule Modify Outbound Rule Click Create. Once you have created the security group for RDS PostgreSQL\n"
},
{
	"uri": "/4-connectordspostgresql/4-3-queryingdata/",
	"title": "Querying Data",
	"tags": [],
	"description": "",
	"content": "After using pgAdmin4 to conntect to RDS PostgreSQL. Now We can perform the basic query statements in this chapter:\nCreate table fcj_users in the pglab database Insert data into the table fcj_users View all the recording in the table View full name user and nationality Get all user from Swedish or American and date of birth from 1980 to 1990. Sort output list descending by date_of_birth List top 5 the youngest users List top 5 the oldest users Check whether the user is missing a date of birth, or first name or last name Right-click on the name of the database to open the menu and click on the “Query Tool” button from the list:\n1.Create table fcj_users in the pglab database\nType the following query in the query tool to create a new table:\nCREATE TABLE fcj_user(\ruser_id SERIAL NOT NULL PRIMARY KEY,\rfirst_name VARCHAR(100),\rlast_name VARCHAR(100),\rgender char(1),\rdate_of_birth DATE,\rnationality VARCHAR (20)\r) 2.Insert data into the table fcj_users\nInsert the data into the fcj_users table using the following query:\nINSERT INTO fcj_users (first_name,last_name,gender,date_of_birth,nationality) VALUES\r(\u0026#39;Malin\u0026#39;,\u0026#39;Akerman\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1978-05-12\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Tim\u0026#39;,\u0026#39;Allen\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1953-06-13\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Julie\u0026#39;,\u0026#39;Andrews\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1935-10-01\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Ivana\u0026#39;,\u0026#39;Baquero\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1994-06-11\u0026#39;,\u0026#39;Bristish\u0026#39;),\r(\u0026#39;Lorraine\u0026#39;,\u0026#39;Bracco\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1954-10-02\u0026#39;,\u0026#39;Mexican\u0026#39;),\r(\u0026#39;Alice\u0026#39;,\u0026#39;Braga\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1983-04-15\u0026#39;,\u0026#39;Japanese\u0026#39;)\r(\u0026#39;Marlon\u0026#39;,\u0026#39;Brando\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1924-04-03\u0026#39;,\u0026#39;American\u0026#39;)\r(\u0026#39;Adrien\u0026#39;,\u0026#39;Brody\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1973-04-14\u0026#39;,\u0026#39;Mexican\u0026#39;),\r(\u0026#39;Peter\u0026#39;,\u0026#39;Carlberg\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1950-12-08\u0026#39;,\u0026#39;Chinese\u0026#39;),\r(\u0026#39;Gemma\u0026#39;,\u0026#39;Chan\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1982-11-29\u0026#39;,\u0026#39;Japanese\u0026#39;),\r(\u0026#39;Chen\u0026#39;,\u0026#39;Chang\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1976-10-14\u0026#39;,\u0026#39;Mexican\u0026#39;),\r(\u0026#39;Graham\u0026#39;,\u0026#39;Chapman\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1941-01-08\u0026#39;,\u0026#39;Japanese\u0026#39;),\r(\u0026#39;Pei-pei\u0026#39;,\u0026#39;Cheng\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1946-12-04\u0026#39;,\u0026#39;Mexican\u0026#39;),\r(\u0026#39;Maggie \u0026#39;,\u0026#39;Cheung\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1964-09-20\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Min-sik\u0026#39;,\u0026#39;Choi\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1962-05-30\u0026#39;,\u0026#39;Chinese\u0026#39;),\r(\u0026#39;Yun-fat\u0026#39;,\u0026#39;Chow\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1955-05-18\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;John\u0026#39;,\u0026#39;Cleese\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1939-10-27\u0026#39;,\u0026#39;British\u0026#39;),\r(\u0026#39;Paddy\u0026#39;,\u0026#39;Considine\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1973-09-05\u0026#39;,\u0026#39;Mexican\u0026#39;),\r(\u0026#39;Abbie\u0026#39;,\u0026#39;Cornish\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1982-08-07\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Brian\u0026#39;,\u0026#39;Cox\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1946-06-01\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Scatman\u0026#39;,\u0026#39;Crothers\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1910-05-23\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Russell\u0026#39;,\u0026#39;Crowe\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1964-04-07\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Tom\u0026#39;,\u0026#39;Cruise\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1962-07-03\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Darlan\u0026#39;,\u0026#39;Cunha\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1988-07-26\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Willem\u0026#39;,\u0026#39;Dafoe\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1955-07-22\u0026#39;,\u0026#39;British\u0026#39;),\r(\u0026#39;Paul\u0026#39;,\u0026#39;Dano\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1984-06-19\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Daniel\u0026#39;,\u0026#39;Day-Lewis\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1957-04-29\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Robert\u0026#39;,\u0026#39;De Niro\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1943-08-17\u0026#39;,\u0026#39;British\u0026#39;),\r(\u0026#39;Marion\u0026#39;,\u0026#39;Brando\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1924-04-03\u0026#39;,\u0026#39;American\u0026#39;),\r(null,\u0026#39;Denden\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1950-01-23\u0026#39;,\u0026#39;Mexican\u0026#39;),\r(\u0026#39;Leonardo\u0026#39;,\u0026#39;DiCaprio\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1974-11-11\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Peter\u0026#39;,\u0026#39;Dinklage\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1969-06-11\u0026#39;,\u0026#39;British\u0026#39;),\r(\u0026#39;Hiroki\u0026#39;,\u0026#39;Doi\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1999-08-10\u0026#39;,\u0026#39;Japanese\u0026#39;),\r(\u0026#39;Kirsten\u0026#39;,\u0026#39;Dunst\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1982-04-30\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Shelley\u0026#39;,\u0026#39;Duvall\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1949-07-07\u0026#39;,\u0026#39;British\u0026#39;),\r(\u0026#39;Ralph\u0026#39;,\u0026#39;Fiennes\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1962-12-22\u0026#39;,\u0026#39;British\u0026#39;),\r(\u0026#39;Leandro\u0026#39;,\u0026#39;Firmino\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1978-06-23\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Carrie\u0026#39;,\u0026#39;Fisher\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1956-10-21\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Harrison\u0026#39;,\u0026#39;Ford\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1942-07-13\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Darian\u0026#39;,\u0026#39;Cunha\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1988-07-26\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Jodie\u0026#39;,\u0026#39;Foster\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1962-11-19\u0026#39;,\u0026#39;Chinese\u0026#39;); 3.View all the recording in the table\nType the following query in the query tool to view all recording: SElECT * FROM fcj_users;\n4.View full name user and nationality\nType the following query in the query tool :\nSELECT first_name || \u0026#39; \u0026#39; || last_name || \u0026#39; from \u0026#39; || nationality AS \u0026#34;Full name\u0026#34; \u0026amp; nationality FROM fcj_users; 5.Get all user from Swedish or American and date of birth from 1980 to 1990. Sort output list descending by date_of_birth\nType the following query in the query tool :\nSELECT * FROM fcj_users\rWHERE nationality = \u0026#39;Swedish\u0026#39; OR\rnationality = \u0026#39;American\u0026#39; AND\rdate_of_birth BETWEEN \u0026#39;1980-01-01\u0026#39; AND \u0026#39;1990-12-31\u0026#39;\rORDER BY date_of_birth DESC; 6.List top 5 the youngest users\nType the following query in the query tool :\nSELECT * FROM fcj_users\rORDER BY date_of_birth DESC\rFETCH FIRST 5 ROW ONLY; 7.List top 5 the oldest users\nType the following query in the query tool :\nSELECT * FROM fcj_users\rORDER BY date_of_birth ASC\rFETCH FIRST 5 ROW ONLY; 9.Check whether the user is missing a date of birth, or first name or last name\nSELECT *\rFROM fcj_users\rWHERE date_of_birth IS NULL\rOR first_name IS NULL\rOR last_name IS NULL ; "
},
{
	"uri": "/3-startwithpostgresql/3-3-tablesdatatypes/",
	"title": "Tables and Datatypes",
	"tags": [],
	"description": "",
	"content": "In this module, we are going to explore Tables and Datatypes.\nThis chapter assumes you have completed the Databases and Schemas chapter. If you haven\u0026rsquo;t, please complete the Databases and Schemas module before proceeding.\nWhat is a Table and why do I see PostgreSQL sometimes call them Relations ?\nFrom the PostgreSQL documentation ,\n\u0026ldquo;PostgreSQL is a relational database management system (RDBMS). That means it is a system for managing data stored in relations. Relation is essentially a mathematical term for table. The notion of storing data in tables is so commonplace today that it might seem inherently obvious, but there are a number of other ways of organizing databases. Files and directories on Unix-like operating systems form an example of a hierarchical database. A more modern development is the object-oriented database.\nEach table is a named collection of rows. Each row of a given table has the same set of named columns, and each column is of a specific data type. Whereas columns have a fixed order in each row, it is important to remember that SQL does not guarantee the order of the rows within the table in any way (although they can be explicitly sorted for display).\nTables are grouped into databases, and a collection of databases managed by a single PostgreSQL server instance constitutes a database cluster.\u0026rdquo;\nExplore Tables 1.In your pgAdmin tool, expand your first_schema inside your first_database.\nThe different kinds of objects (tables, views, functions, etc) that can be part of a PostgreSQL schema.\n2.Right-click on Tables and choose Create then select Table\n3.Name your table first_table.\nThere is an option to make your table partitioned. For this first_table, we will not use table partitioning.\nTable Partitioning in PostgreSQL is an interesting subject. It is interesting because table partitioning has evolved across the PostgreSQL versions. In earlier versions (version 9 and earlier), table partitioning was indirectly supported via the PostgreSQL table inheritance feature (see below). Starting with PostgreSQL version 10, table partition became a native declarative feature. A key thing to remember is that the exact set of table partitioning features supported are tied to the PostgreSQL version. So, be sure you refer to the table partitioning documentation tied to the version of PostgreSQL you are using.\n4.Click on Columns to advance to the Columns tab. Then click on the + sign. Then enter col1 for the Name. Fill out text for the Data type. Click Yes for Not NULL. Click Yes for Primary Key.\nThere is an option to inherit columns from other tables. We will not use table inheritance for this first_table, but it is an interesting and useful PostgreSQL capability to be aware of.\nTable Inheritance in PostgreSQL can be a useful tool for database designers. Table inheritance lets a child table inherit all of the columns of its parent table(s). Further, you can write queries against parent tables that reference the rows of the parent table and all of its descendent tables, too. See the example in the table inheritance documentation to better understand the capabilities.\n5.Browse the available options on the other tabs and end up on the SQL tab. Then click Save.\nExplore Data types As discussed in the documentation ,\n\u0026ldquo;PostgreSQL includes a sizable set of built-in data types that fit many applications. Users can also define their own data types. Most built-in data types have obvious names and semantics, so we defer a detailed explanation to Chapter 8. Some of the frequently used data types are integer for whole numbers, numeric for possibly fractional numbers, text for character strings, date for dates, time for time-of-day values, and timestamp for values containing both date and time.\u0026rdquo;\n1. Numbers\rYou can read more about PostgreSQL number data types here . Here are few quotes from the documentation:\nThe type integer is the common choice [for whole numbers], as it offers the best balance between range, storage size, and performance.\nThe type numeric can store numbers with a very large number of digits. It is especially recommended for storing monetary amounts and other quantities where exactness is required. Calculations with numeric values yield exact results where possible, e.g. addition, subtraction, multiplication. However, calculations on numeric values are very slow compared to the integer types, or to the floating-point types [real and double precision].\nThe data types smallserial, serial and bigserial are not true types, but merely a notational convenience for creating unique identifier columns (similar to the AUTO_INCREMENT property supported by some other databases).\n2. Character\rYou can read more about PostgreSQL character data types here . Here are few quotes from the documentation:\nSQL defines two primary character types: character varying(n) and character(n), where n is a positive integer. Both of these types can store strings up to n characters (not bytes) in length. \u0026hellip; If the string to be stored is shorter than the declared length, values of type character(n) will be space-padded.\nThe notations varchar(n) and char(n) are aliases for character varying(n) and character(n), respectively.\nIn addition, PostgreSQL provides the text type, which stores strings of any length.\nThere is no performance difference among these three types, apart from increased storage space when using the blank-padded type, and a few extra CPU cycles to check the length when storing into a length-constrained column. While character(n) has performance advantages in some other database systems, there is no such advantage in PostgreSQL; in fact character(n) is usually the slowest of the three because of its additional storage costs. In most situations text or character varying should be used instead.\n3. Dates and Times\rYou can read more about PostgreSQL date and time data types here .\nPostgreSQL supports date, time, and timestamp datatypes. The time and timestamp datatypes can be with or without a timezone. The default is without a timezone. The timestampz datatype is an alias for a timestamp with time zone. The time and timestamp datatypes can also be specified with a precision of 0-6 digits of resolution for the seconds. The maximum precision is 1 microsecond.\n4. Other datatypes\rYou can read more about all of the PostgreSQL data types here .\nPostgreSQL has a very rich and extensible set of data types. For example, PostgreSQL has a useful set of JSON-specific datatypes json and jsonb.\nCongratulations!\nYou have learned the basics about PostgreSQL Tables and Datatypes.\n"
},
{
	"uri": "/3-startwithpostgresql/3-4-basicdml/",
	"title": "Basic DML (Data Manipulation Language)",
	"tags": [],
	"description": "",
	"content": "This chapter will talk about queries and basic DML.\nThis chapter assumes you have completed the Tables and Datatypes chapter. If you haven\u0026rsquo;t, please complete the Tables and Datatypes module before proceeding.\nInsert data into our first table 1.In your pgAdmin tool, right click on first_table under your first_schema inside your first_database. Choose Scripts, then click INSERT Script\nThis will create a boilerplate insert statement for our table that we can edit.\\\n2.Highlight the ? placeholder and replace it with 'my first row'. Don\u0026rsquo;t forget to use the ' single-quote mark to surround your text. 3.Click on the Play icon to execute this command.\nThis will run your command and insert your first row. What does \u0026#39;INSERT 0 1\u0026#39; mean ?\rThe 1 in INSERT 0 1 means that it inserted 1 row. The 0 is only applicable if the table uses the classic PostgreSQL OID (Object Identifier), and if so, the 0 represents the actual OID created. Otherwise, it will always return the value 0. These days you probably will not create tables using OIDs, but if you are curious you can read more about OIDs in the documentation .\rIs my row committed ?\rBy default, pgAdmin is set with AutoCommit on, so, yes, this new row should be committed. You can see/change the AutoCommit mode by clicking on the icon next to the Play icon in the pgAdmin Query Editor:\nQuery our first table 1.In your pgAdmin tool, right click on first_table under your first_schema inside your first_database. Choose Scripts, then click SELECT Script 2.Click on the Play icon to execute this command.\nThis will run your command and you should see your first row.\nCreate table second table if not exists 1.Using one of the open query editors, paste in the following create command and then click the Play icon to execute it:\ncreate table if not exists first_schema.second_table(\rcol_pk serial,\rcol_money numeric(12,2),\rcol_short_str varchar(100),\rcol_datetime timestamp(0) without time zone\r); Insert into our second table 1.Using one of the open query editors, paste in the following insert command and then click the Play icon to execute it:\nINSERT INTO first_schema.second_table(\rcol_money, col_short_str, col_datetime)\rVALUES (40.25, \u0026#39;short string\u0026#39;, TIMESTAMP \u0026#39;2004-10-19 10:23:54\u0026#39;) returning col_pk; Notice that because we specified returning col_pk, we see the auto-generated unique value of col_pk in the Data Output section. Remember that when we created second_table that we specified that col_pk used the SERIAL datatype (which is like the AUTO_INCREMENT datatype in other database engines).\nExperimenting with Datatype conversions 1.In one of the open query editors, paste the following select command and click the Play icon to execute it:\nSELECT \u0026#39;40.25\u0026#39; col1, 40.25 col2; Notice in the Data Output section that col1 is a text datatype while col2 is a numeric datatype.\nUnlike certain other databases (specifically Oracle), you do not need to have a FROM clause in your SELECT statement. So if you are in the habit of writing SELECT 'something' FROM dual; in Oracle, you can leave the FROM dual off in PostgreSQL. There is no dual table in PostgreSQL.\n2.Now run this query:\nSELECT \u0026#39;40.25\u0026#39; col1, 40.25 col2, \u0026#39;40.25\u0026#39;::numeric col3, numeric \u0026#39;40.25\u0026#39; col4, cast(\u0026#39;40.25\u0026#39; as numeric) col5; Notice in the Data Output section that col3, col4, and col5 are all examples of text datatypes that have been converted to numeric datatypes. These 3 columns demonstrate 3 ways that you can do datatype conversion in PostgreSQL SQL statements.\n"
},
{
	"uri": "/4-connectordspostgresql/",
	"title": "Connect to RDS PostgreSQL AWS ",
	"tags": [],
	"description": "",
	"content": "After Amazon RDS provisions your DB instance, you can use any standard SQL client application to connect to the instance. In this workshop, we have two ways to connect to RDS PostgreSQL AWS\nUsing pgAdmin4 to connect Using psql to connect This lab contains following tasks: Using pgAdmin4 to connect to RDS PostgreSQL Using psql to connect to RDS PostgreSQL Querying data "
},
{
	"uri": "/2-preparation/2-4-createdbsubnetgroup/",
	"title": "Create DB Subnet group",
	"tags": [],
	"description": "",
	"content": "To create a DB subnet group on AWS, follow these steps: Open the Amazon RDS console In the navigation pane, choose Subnet groups and click on Create DB Subnet Group. For Name and Description, type in a name and description for your DB subnet group. For VPC, select the VPC in which you want to create your DB subnet group. Select the subnets that you want to include in your DB subnet group. Make sure to select subnets in at least two different Availability Zones (AZs). Click Create. Your DB subnet group will be created and will be displayed in the list of DB subnet groups.\nHere are some additional things to keep in mind when creating a DB subnet group:\nYou can only create a DB subnet group in a VPC that is in the same AWS Region as the database engine that you plan to use. You must include at least one subnet in each AZ in which you want to deploy your DB instance. You cannot modify a DB subnet group once it has been created. If you need to change the subnets in your DB subnet group, you must create a new one. You can use a DB subnet group to create a DB instance in any AZ in the VPC. "
},
{
	"uri": "/2-preparation/2-5-createec2appsv/",
	"title": "Create EC2 instance for app server",
	"tags": [],
	"description": "",
	"content": "To create an EC2 instance for an app server, follow these steps: Open the Amazon EC2 console. Click Launch Instance. Choose an AMI. For an app server, you can choose a Linux AMI, such as Amazon Linux 2. Choose an instance type. The instance type that you choose will depend on the requirements of your app server. For example, if you are running a high-traffic website, you will need a larger instance type with more CPU and memory. For Key Pair,choose your keypair you have created or click Create new key pair Configure the instance details. This includes things like the number of instances to launch, the network configuration, and the storage configuration.\nFor Network settings Choose VPC which contains EC2 app server Choose Subnet Enable Auto-assign public IP Add a security group for EC2 app server that you have created easier step . A security group is a firewall that controls incoming and outgoing traffic to your instance. Review and launch the instance Once the instance is launched, you can connect to it using an SSH client, such as MobaXterm or Putty. Once you are connected, you can install your app server and deploy your application.\n"
},
{
	"uri": "/5-helpfulresources/",
	"title": "Helpful Resources",
	"tags": [],
	"description": "",
	"content": "To learn more about pgAdmin4, you can use the Help menu and browse the Online Help.\nBelow are some links to additional relevant content:\nManaging PostgreSQL users and roles RDS for PostgreSQL Common administrator responsibilities on Amazon RDS and Amazon Aurora for PostgreSQL databases Using IAM authentication to connect with pgAdmin Amazon Aurora PostgreSQL or Amazon RDS for PostgreSQL Securing Amazon RDS and Aurora PostgreSQL database access with IAM authentication Working with RDS and Aurora PostgreSQL logs: Part 1 Working with RDS and Aurora PostgreSQL logs: Part 2 "
},
{
	"uri": "/3-startwithpostgresql/3-5-rolesusers/",
	"title": "Roles and Users",
	"tags": [],
	"description": "",
	"content": "\rThis chapter assumes you have completed the Basic DML chapter. If you haven\u0026rsquo;t, please complete the Basic DML module before proceeding.\nThis chapter will talk about PostgreSQL Roles . In PostgreSQL, a role encompasses the concept of both users and groups. The CREATE USER and CREATE GROUP statements are actually aliases for the CREATE ROLE statement. The difference is that a user is role with the LOGIN privilege.\nRoles are defined at the PostgreSQL cluster level and are valid in all databases within the cluster. Role are not created specific to an individual database.\nIn PostgreSQL, schemas are distinct concept from roles/users. This is different than databases such as Oracle.\nExploring Existing Roles In pgAdmin, expand the Login/Group Roles item under your PostgreSQL server.\nYou will see the existing and default roles defined in this PostgreSQL cluster. Notice that there are 2 types of icons that pgAdmin uses for roles. If the role has LOIGN privileges, then it is drawn as a user (such as rdsadmin and masteruser). Otherwise, it is displayed with a group icon.\\\nYou can also retrieve this same information by running the following sql query:\nSELECT rolname FROM pg_roles;\nCreate a new Role 1.Right-click on Login/Group Roles, then choose Create, then choose Login/Group role:\n2.Name the role first_role. 3.Browse through the other tabs of the Create role dialog, but don\u0026rsquo;t change anything. End up on the SQL tab. Then click Save. 4.Right-click on first_database and choose Query Tool icon. 5.Paste and run the following SQL to grant some privileges to your new role.\nGRANT USAGE ON SCHEMA first_schema TO first_role;\rGRANT SELECT ON first_schema.first_table TO first_role; we have granted the role both the ability to SELECT from the table, and also the ability to use the schema that contains the table.\nCreate a new User 1.Right-click on Login/Group Roles, then choose Create, then choose Login/Group role: 2.Name the role first_user.\n3.Click on the Definition tab. Then enter a Password you will remember.\n4.Click on the Privileges tab. Then set Can login? to Yes\n5.Click on the Membership tab. Then click in the Roles field and pick first_role\n6.Finally, click on the SQL tab to see what the SQL looks like. Then Save\nNow, right-click on the Servers node and choose Create, then click Server\n7.Name the new connection first_user_connection\n8.Click on the Connection tab. Enter the RDS endpoint for the hostname (see notes below if you need help finding it). Enter first_user for the Username. Enter your Password you just defined for the new user. Then click Save. 9.Expand the first_user_connection node, then expand Databases. Right-click on first_database, then choose Query Tool to open up a session as first_user. 10.Paste and run this SQL to see if our first_role grants work:\nselect * from first_schema.first_table; 11.Paste and run this SQL to test a table that we have not granted to first_role:\nselect * from first_schema.second_table; Read more about best practices for PostgreSQL User/Role management\nWant to create additional DBA users (similar to masteruser) for your RDS or Aurora PostgreSQL instance? Try this script :\n--replace thepassword with a real password\rCREATE ROLE new_dba_user WITH PASSWORD \u0026#39;thepassword\u0026#39; CREATEDB CREATEROLE LOGIN;\rGRANT rds_superuser TO new_dba_user; "
},
{
	"uri": "/3-startwithpostgresql/3-6-catalodatadictonary/",
	"title": "Catalog and Data dictionary",
	"tags": [],
	"description": "",
	"content": "\rThis chapter assumes you have completed the Basic DML chapter. If you haven\u0026rsquo;t, please complete the Basic DML module before proceeding.\nThis chapter introduces the PostgreSQL Data Dictionary.\nThe pg_catalog schema In addition to public and user-created schemas, each database contains a pg_catalog schema, which contains the system tables and all the built-in data types, functions, and operators.\nThese are a set of tables used to store dynamic and static metadata for the PostgreSQL database and can be thought of as the “data dictionary” for the database. These tables are used for internal “bookkeeping”-type activities. All System catalog tables start with the pg_*prefix and can be found in the pg_catalog schema\n1.In pgAdmin, expand the rdspg-fcj-labs node, then expand the Databases node, then expand the first_database node, then expand the Catalogs node, then expand the PostgreSQL Catalog, then expand Tables.\nYou can see the tables in the pg_catalog schema.\n2.Click on the first_database, then choose Query Tool icon\n3.Paste and run this command to see an example of querying the pg_catalog directly:\nselect * from pg_tables where schemaname='pg_catalog'; The Statistics Collector Views (also part of pg_catalog) The Statistics Collector is a special subsystem which collects runtime dynamic information about the current activities in the database instance. For example, statistics collector views are useful to determine how frequently a particular table is accessed and if the table is scanned or accessed using an index.\n1.Paste and run this command to see an example of one of the Statistics Collector views:\nSELECT * FROM pg_stat_activity WHERE STATE = 'active';\n2.lick on the rds-pg-labs node. Then click on Dashboard. Then click on Sessions in the Server activity section. Here, pgAdmin is showing you the same pg_stat_activity information for your PostgreSQL cluster.\nTip: Performance Insights is a great way to visualize current and historical activity and wait events. We encourage you to start with Performance Insights for performance-related diagnostics.\nPerformance Insights is a great way to visualize current and historical activity and wait events. We encourage you to start with Performance Insights for performance-related diagnostics.\n3.Paste and run this command to see an example of one of the Statistics Collector views: select * from information_schema.tables;\n"
},
{
	"uri": "/6-cleanup/",
	"title": "Clean up resources",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/2-preparation/2-6-createec2bastionhost/",
	"title": "Create bastion host EC2 instance ",
	"tags": [],
	"description": "",
	"content": "\rWe will connect to a PostgreSQL RDS instance using pgAdmin 4 through a jump host EC2 bastion host\nTo create an EC2 instance for bastion host , follow these steps: Open the Amazon EC2 console. Click Launch Instance. 3. Name for EC2 bastion host\n3. Choose an AMI. For an app server, you can choose a Linux AMI, such as Amazon Linux 2.\nChoose an instance type. The instance type that you choose will depend on the requirements of your app server. For example, if you are running a high-traffic website, you will need a larger instance type with more CPU and memory. For Key Pair,choose your keypair you have created or click Create new key pair Configure the instance details. This includes things like the number of instances to launch, the network configuration, and the storage configuration.\nFor Network settings Choose VPC which contains EC2 app server Choose Subnet Enable Auto-assign public IP Add a security group for EC2 app server that you have created easier step . A security group is a firewall that controls incoming and outgoing traffic to your instance. Review and launch the instance "
},
{
	"uri": "/2-preparation/2-7-createrdsdb/",
	"title": "Create RDS PostgreSQL DB",
	"tags": [],
	"description": "",
	"content": "To create an RDS PostgreSQL DB, follow these steps: Open the Amazon RDS console. Click Create database. For Database engine, select PostgreSQL. For Version, select the version of PostgreSQL that you want to use. For Template, select a template for your DB instance. A template is a pre-configured configuration for a DB instance. For Availability and Durability, For DB instance identifier, enter a name for your DB instance. For DB instance identifier, enter a unique name for your database instance. For Master username, enter the username for the master user of your database instance. For Master password, enter a strong password for the master user of your database instance. For DB instance class, select the instance class that you want to use for your database instance. The instance class will determine the amount of CPU and memory that is allocated to your database instance. For Storage, select the amount of storage that you want to allocate for your database instance. For Connectivity, select option Connect to a EC2 compute resource, then choose your App server instance which you have created in the earier step. For DB subnet group, select the DB subnet group that you want to use for your DB instance. For VPC security groups, select the security groups that you want to use for your DB instance. Expand Additional configuration, Enter 5432 for database port For Database authentication, choose option that you want to use For Monitoring, select the monitoring options that you want to use for your database instance Expand Additional configuration: For Database option, fill name for database you want create after lauch RDS PostgreSQL For DB parameter group, leave everything with default setting For Backup, select the backup options that you want to use for your database instance. Click Create database. Your database instance will be created and will be displayed in the list of database instances. You can connect to it using a PostgreSQL client, such as psql, pgAdmin4. To do this, you will need the hostname, port number, and username and password for your database instance.\nHere are some additional things to keep in mind when creating an RDS PostgreSQL DB: Click here\rYou can only create an RDS PostgreSQL DB in a VPC that is in the same AWS Region as the database engine that you plan to use. You must choose an instance class that is compatible with the PostgreSQL version that you want to use. You can choose to create your database instance in a single Availability Zone (AZ) or in multiple AZs. If you choose to create your database instance in multiple AZs, you will be able to take advantage of high availability and disaster recovery features. You can choose to enable encryption for your database instance. This will encrypt your data at rest and in transit. You can choose to enable backups for your database instance. This will allow you to restore your database to a previous point in time if something goes wrong. "
},
{
	"uri": "/3-startwithpostgresql/3-7-sessionparameters/",
	"title": "Session parameters",
	"tags": [],
	"description": "",
	"content": "\rThis chapter assumes you have completed the Basic DML chapter. If you haven\u0026rsquo;t, please complete the Basic DML module before proceeding.\nThis chapter will talk about PostgreSQL Parameters . Specifically, it will focus on parameters that can be changed at the session-level. For system-wide parameters, you would leverage RDS/Aurora\u0026rsquo;s Parameter Group mechanism.\n1.In pgAdmin, click on the rdspg-fcj-labs node, then click on Dashboard, then click on Configuration.\nThis shows you the current setting of all the PostgreSQL parameter settings.\n2.In the search box, type search\nThis filters down the list of parameter settings.\n3.Click on first_database, then choose Query Tool icon. Then paste and run the following SQL:\nSELECT * FROM pg_settings where context = 'user';\nThis shows you the parameter sessions that can be changed for a session, as well as their current setting.\n4.Paste and run the following SQL:\nshow search_path The SHOW command is another way to view the current value of a setting for your session.\n5.Paste and run the following SQL: show all This shows you yet another way to view the current value of all of the parameter settings for your session.\n6.Paste and try the following SQL: select * from first_table; This fails because PostgreSQL is not able to find a table named first_table in the schemas in the current search_path.\n7.Paste and try the following SQL: SET search_path TO first_schema, public; 8.Paste and try the following SQL again: select * from first_table; This now works because we updated the search_path parameter setting for our session.\nWhen making changes to system parameters via RDS/Aurora Parameter Groups, it is a good idea to confirm that your parameter change has been applied by using one of the techniques above, such as \u0026ldquo;SHOW ALL\u0026rdquo;, to confirm that the expected parameter value is in effect. Sometimes people can be confused because their Parameter Group change can be made but the actual parameter setting change does not happen until the next reboot. Confirming the value using \u0026ldquo;SHOW ALL\u0026rdquo; or one of the other methods can save you confusion and time\n"
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]