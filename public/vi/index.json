[
{
	"uri": "/vi/",
	"title": "AWS RDS PostgreSQL",
	"tags": [],
	"description": "",
	"content": "Let start with AWS RDS PostgreSQL Overall In this lab, you\u0026rsquo;ll learn the basics and practice of Amazon RDS PostgreSQL\nContent Introduction Start with PostgreSQL Create RDS PostgreSQL Database Instance Connect to pgAdmin4 Helpful Resources Clean up resources "
},
{
	"uri": "/vi/4-connectopgadmin4/4-1-configuretheclient/",
	"title": "Configure the database client",
	"tags": [],
	"description": "",
	"content": "After Amazon RDS provisions your DB instance, you can use any standard SQL client application to connect to the instance. Before you can connect, the DB instance must be available and accessible. Whether you can connect to the instance from outside the VPC depends on how you created the Amazon RDS DB instance:\nIf you created your DB instance as public, devices and Amazon EC2 instances outside the VPC can connect to your database. If you created your DB instance as private, only Amazon EC2 instances and devices inside the Amazon VPC can connect to your database. In this chapter, we will use pgAdmin4 to connect to a RDS for PostgreSQL DB instance, so we need create DB as public.\nYou can use the open-source tool pgAdmin4 to connect to your RDS for PostgreSQL DB instance. You can download and install pgAdmin from http://www.pgadmin.org/ without having a local instance of PostgreSQL on your client computer\n1.Launch the pgAdmin4 application on your client computer.\n2.On the Dashboard tab, choose Add New Server. 3.In the Create - Server dialog box, type a name on the General tab to identify the server in pgAdmin4. 4.In the Connection tab, type the following information from your DB instance:\nFor Host, type the endpoint you have retrieve in the step 3.2, for example mypostgresql.c6c8dntfzzhgv0.us-east-2.rds.amazonaws.com. For Port, type the assigned port. For Username, type the user name that you entered when you created the DB instance. For Password, type the password that you entered when you created the DB instance. 5.Choose Save. If you have any problems connecting, see Troubleshooting connections to your RDS for PostgreSQL instance.\n"
},
{
	"uri": "/vi/3-createrdspostgresql/3-1-createdbinstance/",
	"title": "Create DB instane",
	"tags": [],
	"description": "",
	"content": "1.Open AWS Management console,\nFind RDS Select RDS 2.Click Create database to start the configuration process. In the Choose a database creation method section, ensure the Standard Create option is selected. Next, in the Engine options section, choose the PostgreSQL engine type and the PostgreSQL 15.3-R2 version. In the Templates section, select Free tier.\nWhen using RDS free tier which has not support feature Availability and Durability.\nIn the Settings section, set the DB instance identifier to rdspg-fcj-labs. Configure the name and password of the master database user, with the most elevated permissions in the database.\nIn the DB instance size section, select Burstable classes, and choose db.t3.micro in the size drop-down\nIn the Storage Section, leave with default setting.\\ Expand Storage autoscaling, then **Uncheck **the Enable storage autoscaling box. In the Connectivity section, leave with default setting In the Database authentication section, choose Password authentication\nIn the Monitoring section, we will use default setting In the Additional configuration,\nFill your Initial database name\nUncheck Enable automated backups\nUncheck Enable encryption Check all option in Log exports\nCheck Enable auto minor version upgrade\nChoose No preference for Maintenance window\nFinally, review Estimated Monthly costs then select Create database "
},
{
	"uri": "/vi/1-introduce/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "PostgreSQL has become the preferred open source relational database for many enterprise developers and startups, powering leading business and mobile applications. Amazon RDS makes it easier to set up, operate, and scale PostgreSQL deployments on the cloud. With Amazon RDS, you can deploy scalable PostgreSQL deployments in minutes with cost-efficient and resizable hardware capacity. Amazon RDS manages complex and time-consuming administrative tasks such as PostgreSQL software installation and upgrades, storage management, replication for high availability and read throughput, and backups for disaster recovery.\nAmazon RDS for PostgreSQL gives you access to the capabilities of the familiar PostgreSQL database engine. This means that the code, applications, and tools you already use today with your existing databases can be used with Amazon RDS. Amazon RDS for PostgreSQL currently supports PostgreSQL 9.6, 10, 11, 12, 13, 14, and 15. With Trusted Language Extensions (TLE) for PostgreSQL, you can build high performance extensions and safely run them on Amazon RDS using popular trusted languages without needing AWS to certify code.\nBy using AWS RDS PostgreSQL, you will get the following benefit below:\nEasier, managed deployments Fast, predictable storage Backup and recovery High availability and read replicas Monitoring and metrics Isolation and security "
},
{
	"uri": "/vi/2-startwithpostgresql/2-1-pgadmin/",
	"title": "pgAdmin4",
	"tags": [],
	"description": "",
	"content": "The pgAdmin4 tool is a very popular database administration and development platform for the PostgreSQL database. We will use pgAdmin to help introduce PostgreSQL to you.\npgAdmin can be installed locally on your desktop or it can be run on a server and accessed via a web browser. In this lab, we will deploy pgAdmin in your desktop via link download image.\n"
},
{
	"uri": "/vi/2-startwithpostgresql/2-2-databaseschemas/",
	"title": "Database and Schemas",
	"tags": [],
	"description": "",
	"content": "Welcome to PostgreSQL! If this is your first time looking at PostgreSQL, we encourage you to check out the official About PostgreSQL webpage.\nIn this module, we are going to explore Databases and Schemas.\nThis chapter assumes you have setup and configured pgAdmin. If you haven\u0026rsquo;t, please complete the pgAdmin module before proceeding.\nExplore Databases 1.In your pgAdmin tool, click the \u0026gt; in front of rdspg-fcj-labs to expand it.\nYou see 3 breakouts: Databases, Login/Group Roles, and Tablespaces.\nIn this section, we will focus on Databases. And we\u0026rsquo;ll cover Login/Group Roles in a later section.\n2.Expand the Databases node.\nFrom a terminology standpoint, the PostgreSQL instance (rdspg-fcj-labs) you have created is known as a PostgreSQL cluster. A cluster contains one or more databases. While the users/roles of a cluster are shared across a cluster, no data is shared across databases. In other words, when a customer connects to a cluster, that connection is required to specify the database it wants to work with and that connection can only work within a single database at a time.\nyou see a handful of databases within the pglab cluster.\nWhat is the `rdsadmin` database ?\rThe database named rdsadmin is a database that is reserved for use by the RDS/Aurora control plane.\r3.Right-click on the Databases node and choose Create, then click Databases\n4.Name the database first_database (but don\u0026rsquo;t save it yet)\nThe database has an owner. This role can control and assign permissions for this database to other roles. The owner defaults to the role you are currently logged in with pgAdmin. Also note that you can alter the owner of most PostgreSQL objects even after they are originally created.\n5.Now click on the Definition tab\nThere are various settings that can be changed. You don\u0026rsquo;t need to change anything for now.\n6.Click on the SQL tab\nThe SQL tab shows you a preview of the generated SQL command that pgAdmin is going to run.\n7.Click Save 8.Find your new database in the navigator and expand it. Explore Schemas A database contains one or more named schemas, which in turn contain tables and other objects like views and functions. The objects in a given PostgreSQL schema can be owned by different users and the schema name has no implied correlation to the name of the schema owner.\nAs described in the PostgreSQL Documentation\n\u0026quot; The same object name can be used in different schemas without conflict; for example, both schema1 and myschema may contain tables named mytable. Unlike databases, schemas are not rigidly separated: a user may access objects in any of the schemas in the database he is connected to, if he has privileges to do so.\nThere are several reasons why one might want to use schemas:\nTo allow many users to use one database without interfering with each other. To organize database objects into logical groups to make them more manageable. Third-party applications can be put into separate schemas so they cannot collide with the names of other objects. Schemas are analogous to directories at the operating system level, except that schemas cannot be nested.\u0026quot;\n1.Expand the Schemas node and see a default public schema.\n2.Right-click on the Schemas node and choose Create, then click Schema.\n3.Name the schema first_schema\nThe schemas have an owner and also have security permissions and default privileges for new objects created in the schema (you can click on the Security tab and the Default Permissions tab in the Create Schema dialog if you want).\n4.Click Save to create the new schema.\nPostgreSQL schemas can be different from how other databases like Oracle implement schemas. In Oracle, schemas are directly mapped 1:1 to users. In PostgreSQL, schemas are not coupled directly to a specific user(role).\nAs discussed in the documentation ,\n\u0026ldquo;In the SQL standard, the notion of objects in the same schema being owned by different users does not exist. Moreover, some implementations do not allow you to create schemas that have a different name than their owner. In fact, the concepts of schema and user are nearly equivalent in a database system that implements only the basic schema support specified in the standard. Therefore, many users consider qualified names to really consist of username.tablename. This is how PostgreSQL will effectively behave if you create a per-user schema for every user. Also, there is no concept of a public schema in the SQL standard. For maximum conformance to the standard, you should not use (perhaps even remove) the public schema.\u0026rdquo;\nA note about the search_path Referencing objects via Qualified names, such as first_schema.first_table, is tedious to write, and hard-coding a particular schema name into an application is not ideal. The solution is to use unqualified names, such as first_table and this is made possible via the PostgreSQL search_path.\nAs discussed in the documentation ,\n\u0026ldquo;The system determines which table is meant by following a search_path, which is a list of schemas to look in. The first matching table in the search path is taken to be the one wanted. If there is no match in the search path, an error is reported, even if matching table names exist in other schemas in the database.\nThe first schema named in the search path is called the current schema. Aside from being the first schema searched, it is also the schema in which new tables will be created if the CREATE TABLE command does not specify a schema name.\u0026rdquo;\nBy default, the search_path is set to $user,public. As the documentation states\n\u0026ldquo;The first element specifies that a schema with the same name as the current user is to be searched. If no such schema exists, the entry is ignored. The second element refers to the public schema that we have seen already.\u0026rdquo;\nIt should be noted that PostgreSQL does not have the concept of synonyms like certain other databases. You can use the search_path to handle some, but not all, of the capabilities that synonyms offer. For an example of implementing other synonym-like functionality in PostgreSQL, see this blog post .\nCongratulations!\nYou have learned the basics about PostgreSQL Databases and Schemas.\u0026mdash; title : \u0026ldquo;Database and Schemas\u0026rdquo; date : \u0026ldquo;r Sys.Date()\u0026rdquo; weight : 2 chapter : false pre : \u0026quot; 2.2. \u0026quot; Welcome to PostgreSQL! If this is your first time looking at PostgreSQL, we encourage you to check out the official About PostgreSQL webpage.\nIn this module, we are going to explore Databases and Schemas.\nThis chapter assumes you have setup and configured pgAdmin. If you haven\u0026rsquo;t, please complete the pgAdmin module before proceeding.\nExplore Databases 1.In your pgAdmin tool, click the \u0026gt; in front of rdspg-fcj-labs to expand it.\nYou see 3 breakouts: Databases, Login/Group Roles, and Tablespaces.\nIn this section, we will focus on Databases. And we\u0026rsquo;ll cover Login/Group Roles in a later section.\n2.Expand the Databases node.\nFrom a terminology standpoint, the PostgreSQL instance (rdspg-fcj-labs) you have created is known as a PostgreSQL cluster. A cluster contains one or more databases. While the users/roles of a cluster are shared across a cluster, no data is shared across databases. In other words, when a customer connects to a cluster, that connection is required to specify the database it wants to work with and that connection can only work within a single database at a time.\nyou see a handful of databases within the pglab cluster.\nWhat is the `rdsadmin` database ?\rThe database named rdsadmin is a database that is reserved for use by the RDS/Aurora control plane.\r3.Right-click on the Databases node and choose Create, then click Databases\n4.Name the database first_database (but don\u0026rsquo;t save it yet)\nThe database has an owner. This role can control and assign permissions for this database to other roles. The owner defaults to the role you are currently logged in with pgAdmin. Also note that you can alter the owner of most PostgreSQL objects even after they are originally created.\n5.Now click on the Definition tab\nThere are various settings that can be changed. You don\u0026rsquo;t need to change anything for now.\n6.Click on the SQL tab\nThe SQL tab shows you a preview of the generated SQL command that pgAdmin is going to run.\n7.Click Save 8.Find your new database in the navigator and expand it. Explore Schemas A database contains one or more named schemas, which in turn contain tables and other objects like views and functions. The objects in a given PostgreSQL schema can be owned by different users and the schema name has no implied correlation to the name of the schema owner.\nAs described in the PostgreSQL Documentation\n\u0026quot; The same object name can be used in different schemas without conflict; for example, both schema1 and myschema may contain tables named mytable. Unlike databases, schemas are not rigidly separated: a user may access objects in any of the schemas in the database he is connected to, if he has privileges to do so.\nThere are several reasons why one might want to use schemas:\nTo allow many users to use one database without interfering with each other. To organize database objects into logical groups to make them more manageable. Third-party applications can be put into separate schemas so they cannot collide with the names of other objects. Schemas are analogous to directories at the operating system level, except that schemas cannot be nested.\u0026quot;\n1.Expand the Schemas node and see a default public schema.\n2.Right-click on the Schemas node and choose Create, then click Schema.\n3.Name the schema first_schema\nThe schemas have an owner and also have security permissions and default privileges for new objects created in the schema (you can click on the Security tab and the Default Permissions tab in the Create Schema dialog if you want).\n4.Click Save to create the new schema.\nPostgreSQL schemas can be different from how other databases like Oracle implement schemas. In Oracle, schemas are directly mapped 1:1 to users. In PostgreSQL, schemas are not coupled directly to a specific user(role).\nAs discussed in the documentation ,\n\u0026ldquo;In the SQL standard, the notion of objects in the same schema being owned by different users does not exist. Moreover, some implementations do not allow you to create schemas that have a different name than their owner. In fact, the concepts of schema and user are nearly equivalent in a database system that implements only the basic schema support specified in the standard. Therefore, many users consider qualified names to really consist of username.tablename. This is how PostgreSQL will effectively behave if you create a per-user schema for every user. Also, there is no concept of a public schema in the SQL standard. For maximum conformance to the standard, you should not use (perhaps even remove) the public schema.\u0026rdquo;\nA note about the search_path Referencing objects via Qualified names, such as first_schema.first_table, is tedious to write, and hard-coding a particular schema name into an application is not ideal. The solution is to use unqualified names, such as first_table and this is made possible via the PostgreSQL search_path.\nAs discussed in the documentation ,\n\u0026ldquo;The system determines which table is meant by following a search_path, which is a list of schemas to look in. The first matching table in the search path is taken to be the one wanted. If there is no match in the search path, an error is reported, even if matching table names exist in other schemas in the database.\nThe first schema named in the search path is called the current schema. Aside from being the first schema searched, it is also the schema in which new tables will be created if the CREATE TABLE command does not specify a schema name.\u0026rdquo;\nBy default, the search_path is set to $user,public. As the documentation states\n\u0026ldquo;The first element specifies that a schema with the same name as the current user is to be searched. If no such schema exists, the entry is ignored. The second element refers to the public schema that we have seen already.\u0026rdquo;\nIt should be noted that PostgreSQL does not have the concept of synonyms like certain other databases. You can use the search_path to handle some, but not all, of the capabilities that synonyms offer. For an example of implementing other synonym-like functionality in PostgreSQL, see this blog post .\nCongratulations!\nYou have learned the basics about PostgreSQL Databases and Schemas.\n"
},
{
	"uri": "/vi/3-createrdspostgresql/3-2-retrievebdinstancendpoint/",
	"title": "Retrieve DB instance endpoint",
	"tags": [],
	"description": "",
	"content": "The PostgreSQL database instance may take several minutes to provision. In order to connect to the DB instance and start using it in subsequent labs, you need to retrieve the DB instance endpoint.\nThe Endpoint \u0026amp; port section in the Connectivity and security tab of the details page displays the endpoint. Note this value down, as you will use them later. "
},
{
	"uri": "/vi/2-startwithpostgresql/",
	"title": "Start with PostgreSQL",
	"tags": [],
	"description": "",
	"content": "This lab contains following tasks: Content pgAdmin Database and Schemas Tables and Datatypes Basic DML Role and Users Procedural Code Catalog and Data dictionary Session parameters "
},
{
	"uri": "/vi/4-connectopgadmin4/4-2-queryingdata/",
	"title": "Verify DB instance",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/vi/3-createrdspostgresql/",
	"title": "Create RDS PostgreSQL Database Instance",
	"tags": [],
	"description": "",
	"content": "This lab contains following tasks: Content Create DB instance Retrieve DB instance endpoint Store user/password database in AWS Secrets Manager secret "
},
{
	"uri": "/vi/3-createrdspostgresql/3-3-storeaccountinawssms/",
	"title": "Password management with Amazon RDS and AWS Secrets Manager",
	"tags": [],
	"description": "",
	"content": "Secrets Manager enables you to replace hardcoded credentials in your code, including passwords, with an API call to Secrets Manager to retrieve the secret programmatically. This helps ensure the secret can\u0026rsquo;t be compromised by someone examining your code, because the secret no longer exists in the code.\n1.Open AWS Management console,\nFind Secrets Manager Select Secrets Manager 2.Click Store a new secret to start the configuration process.\n3.In the Select secret type section,\nChoose Credentials for RDS database\nInput the User name (should be masteruser) and Password that you provided when you created the DB cluster previously. Next, in the Select which RDS database this secret will access section, choose the DB instance identifier you assigned to your instance (e.g. rdspg-fcj-labs). Click Next.\n4.Name the secret secretPostgresqlMasterUser and provide a relevant description for the secret, then click Next.\nBe sure to use the exact name (case-sensitive) of secretPostgresqlMasterUser to avoid having to edit some of the lab scripts later.\n5.Finally, in the Configure automatic rotation section, leave the option of Disable automatic rotation selected. In a production environment you will want to use database credentials that rotate automatically for additional security. Click Next. 6.In the Review section you have the ability to check the configuration parameters for your secret, before it gets created. Additionally, you can retrieve sample code in popular programming languages, so you can easily retrieve secrets into your application. Click Store at the bottom of the screen.\n"
},
{
	"uri": "/vi/2-startwithpostgresql/2-3-tablesdatatypes/",
	"title": "Tables and Datatypes",
	"tags": [],
	"description": "",
	"content": "In this module, we are going to explore Tables and Datatypes.\nThis chapter assumes you have completed the Databases and Schemas chapter. If you haven\u0026rsquo;t, please complete the Databases and Schemas module before proceeding.\nWhat is a Table and why do I see PostgreSQL sometimes call them Relations ?\nFrom the PostgreSQL documentation ,\n\u0026ldquo;PostgreSQL is a relational database management system (RDBMS). That means it is a system for managing data stored in relations. Relation is essentially a mathematical term for table. The notion of storing data in tables is so commonplace today that it might seem inherently obvious, but there are a number of other ways of organizing databases. Files and directories on Unix-like operating systems form an example of a hierarchical database. A more modern development is the object-oriented database.\nEach table is a named collection of rows. Each row of a given table has the same set of named columns, and each column is of a specific data type. Whereas columns have a fixed order in each row, it is important to remember that SQL does not guarantee the order of the rows within the table in any way (although they can be explicitly sorted for display).\nTables are grouped into databases, and a collection of databases managed by a single PostgreSQL server instance constitutes a database cluster.\u0026rdquo;\nExplore Tables 1.In your pgAdmin tool, expand your first_schema inside your first_database.\nThe different kinds of objects (tables, views, functions, etc) that can be part of a PostgreSQL schema.\n2.Right-click on Tables and choose Create then select Table\n3.Name your table first_table.\nThere is an option to make your table partitioned. For this first_table, we will not use table partitioning.\nTable Partitioning in PostgreSQL is an interesting subject. It is interesting because table partitioning has evolved across the PostgreSQL versions. In earlier versions (version 9 and earlier), table partitioning was indirectly supported via the PostgreSQL table inheritance feature (see below). Starting with PostgreSQL version 10, table partition became a native declarative feature. A key thing to remember is that the exact set of table partitioning features supported are tied to the PostgreSQL version. So, be sure you refer to the table partitioning documentation tied to the version of PostgreSQL you are using.\n4.Click on Columns to advance to the Columns tab. Then click on the + sign. Then enter col1 for the Name. Fill out text for the Data type. Click Yes for Not NULL. Click Yes for Primary Key.\nThere is an option to inherit columns from other tables. We will not use table inheritance for this first_table, but it is an interesting and useful PostgreSQL capability to be aware of.\nTable Inheritance in PostgreSQL can be a useful tool for database designers. Table inheritance lets a child table inherit all of the columns of its parent table(s). Further, you can write queries against parent tables that reference the rows of the parent table and all of its descendent tables, too. See the example in the table inheritance documentation to better understand the capabilities.\n5.Browse the available options on the other tabs and end up on the SQL tab. Then click Save.\nCongratulations!\nYou have learned the basics about PostgreSQL Tables and Datatypes.\n"
},
{
	"uri": "/vi/2-startwithpostgresql/2-4-basicdml/",
	"title": "Basic DML",
	"tags": [],
	"description": "",
	"content": "This chapter will talk about queries and basic DML.\nThis chapter assumes you have completed the Tables and Datatypes chapter. If you haven\u0026rsquo;t, please complete the Tables and Datatypes module before proceeding.\nInsert data into our first table 1.In your pgAdmin tool, right click on first_table under your first_schema inside your first_database. Choose Scripts, then SELECT Script\nThis will create a boilerplate insert statement for our table that we can edit.\n2.Highlight the ? placeholder and replace it with 'my first row'. Don\u0026rsquo;t forget to use the ' single-quote mark to surround your text.\n3.Click on the Play icon to execute this command.\nThis will run your command and insert your first row.\nWhat does \u0026#39;INSERT 0 1\u0026#39; mean ?\rThe 1 in INSERT 0 1 means that it inserted 1 row. The 0 is only applicable if the table uses the classic PostgreSQL OID (Object Identifier), and if so, the 0 represents the actual OID created. Otherwise, it will always return the value 0. These days you probably will not create tables using OIDs, but if you are curious you can read more about OIDs in the documentation .\rIs my row committed ?\rBy default, pgAdmin is set with AutoCommit on, so, yes, this new row should be committed. You can see/change the AutoCommit mode by clicking on the icon next to the Play icon in the pgAdmin Query Editor: Query our first table 1.In your pgAdmin tool, right click on first_table under your first_schema inside your first_database. Choose Scripts, then SELECT Script\n2.Click on the Play icon to execute this command.\nThis will run your command and you should see your first row.\nCreate table second table if not exists 1.Using one of the open query editors, paste in the following create command and then click the Play icon to execute it:\ncreate table if not exists first_schema.second_table(\rcol_pk serial,\rcol_money numeric(12,2),\rcol_short_str varchar(100),\rcol_datetime timestamp(0) without time zone\r); Insert into our second table 1.Using one of the open query editors, paste in the following insert command and then click the Play icon to execute it:\nINSERT INTO first_schema.second_table(\rcol_money, col_short_str, col_datetime)\rVALUES (40.25, \u0026#39;short string\u0026#39;, TIMESTAMP \u0026#39;2004-10-19 10:23:54\u0026#39;) returning col_pk; Notice that because we specified returning col_pk, we see the auto-generated unique value of col_pk in the Data Output section. Remember that when we created second_table that we specified that col_pk used the SERIAL datatype (which is like the AUTO_INCREMENT datatype in other database engines).\nExperimenting with Datatype conversions 1.In one of the open query editors, paste the following select command and click the Play icon to execute it:\nSELECT \u0026#39;40.25\u0026#39; col1, 40.25 col2; Notice in the Data Output section that col1 is a text datatype while col2 is a numeric datatype.\nUnlike certain other databases (specifically Oracle), you do not need to have a FROM clause in your SELECT statement. So if you are in the habit of writing SELECT 'something' FROM dual; in Oracle, you can leave the FROM dual off in PostgreSQL. There is no dual table in PostgreSQL.\n2.Now run this query:\nSELECT \u0026#39;40.25\u0026#39; col1, 40.25 col2, \u0026#39;40.25\u0026#39;::numeric col3, numeric \u0026#39;40.25\u0026#39; col4, cast(\u0026#39;40.25\u0026#39; as numeric) col5; Notice in the Data Output section that col3, col4, and col5 are all examples of text datatypes that have been converted to numeric datatypes. These 3 columns demonstrate 3 ways that you can do datatype conversion in PostgreSQL SQL statements.\n"
},
{
	"uri": "/vi/4-connectopgadmin4/",
	"title": "Import data into PostgreSQl",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/vi/5-helpfulresources/",
	"title": "Querying data",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/vi/2-startwithpostgresql/2-5-rolesusers/",
	"title": "Roles and Users",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/vi/2-startwithpostgresql/2-6-catalodatadictonary/",
	"title": "Catalog and Data dictionary",
	"tags": [],
	"description": "",
	"content": "\rThis chapter assumes you have completed the Basic DML chapter. If you haven\u0026rsquo;t, please complete the Basic DML module before proceeding.\nThis chapter introduces the PostgreSQL Data Dictionary.\nThe pg_catalog schema In addition to public and user-created schemas, each database contains a pg_catalog schema, which contains the system tables and all the built-in data types, functions, and operators.\nThese are a set of tables used to store dynamic and static metadata for the PostgreSQL database and can be thought of as the “data dictionary” for the database. These tables are used for internal “bookkeeping”-type activities. All System catalog tables start with the pg_*prefix and can be found in the pg_catalog schema\n1.In pgAdmin, expand the rdspg-fcj-labs node, then expand the Databases node, then expand the first_database node, then expand the Catalogs node, then expand the PostgreSQL Catalog, then expand Tables.\nYou can see the tables in the pg_catalog schema.\n2.Click on the first_database, then choose Query Tool icon\n3.Paste and run this command to see an example of querying the pg_catalog directly:\nselect * from pg_tables where schemaname='pg_catalog'; The Statistics Collector Views (also part of pg_catalog) The Statistics Collector is a special subsystem which collects runtime dynamic information about the current activities in the database instance. For example, statistics collector views are useful to determine how frequently a particular table is accessed and if the table is scanned or accessed using an index.\n1.Paste and run this command to see an example of one of the Statistics Collector views:\nSELECT * FROM pg_stat_activity WHERE STATE = 'active';\n2.lick on the rds-pg-labs node. Then click on Dashboard. Then click on Sessions in the Server activity section. Here, pgAdmin is showing you the same pg_stat_activity information for your PostgreSQL cluster.\nTip: Performance Insights is a great way to visualize current and historical activity and wait events. We encourage you to start with Performance Insights for performance-related diagnostics.\nPerformance Insights is a great way to visualize current and historical activity and wait events. We encourage you to start with Performance Insights for performance-related diagnostics.\n3.Paste and run this command to see an example of one of the Statistics Collector views: select * from information_schema.tables;\n"
},
{
	"uri": "/vi/6-cleanup/",
	"title": "Clean up resources",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/vi/2-startwithpostgresql/2-7-sessionparameters/",
	"title": "Session parameters",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]